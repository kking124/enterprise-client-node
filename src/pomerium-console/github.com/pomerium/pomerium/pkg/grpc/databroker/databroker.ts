// @generated by protobuf-ts 2.9.4 with parameter generate_dependencies
// @generated from protobuf file "github.com/pomerium/pomerium/pkg/grpc/databroker/databroker.proto" (package "databroker", syntax proto3)
// tslint:disable
import { Empty } from "../../../../../../google/protobuf/empty";
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Duration } from "../../../../../../google/protobuf/duration";
import { FieldMask } from "../../../../../../google/protobuf/field_mask";
import { Struct } from "../../../../../../google/protobuf/struct";
import { Timestamp } from "../../../../../../google/protobuf/timestamp";
import { Any } from "../../../../../../google/protobuf/any";
/**
 * @generated from protobuf message databroker.Record
 */
export interface Record {
    /**
     * @generated from protobuf field: uint64 version = 1;
     */
    version: bigint;
    /**
     * @generated from protobuf field: string type = 2;
     */
    type: string;
    /**
     * @generated from protobuf field: string id = 3;
     */
    id: string;
    /**
     * @generated from protobuf field: google.protobuf.Any data = 4;
     */
    data?: Any;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp modified_at = 5;
     */
    modifiedAt?: Timestamp;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp deleted_at = 6;
     */
    deletedAt?: Timestamp;
}
/**
 * @generated from protobuf message databroker.Versions
 */
export interface Versions {
    /**
     * the server version indicates the version of the server storing the data
     *
     * @generated from protobuf field: uint64 server_version = 1;
     */
    serverVersion: bigint;
    /**
     * @generated from protobuf field: uint64 latest_record_version = 2;
     */
    latestRecordVersion: bigint;
}
/**
 * Options are the options for a type stored in the databroker.
 *
 * @generated from protobuf message databroker.Options
 */
export interface Options {
    /**
     * capacity sets a maximum size for the given type. Once the capacity is
     * reached the oldest records will be removed.
     *
     * @generated from protobuf field: optional uint64 capacity = 1;
     */
    capacity?: bigint;
}
/**
 * @generated from protobuf message databroker.GetRequest
 */
export interface GetRequest {
    /**
     * @generated from protobuf field: string type = 1;
     */
    type: string;
    /**
     * @generated from protobuf field: string id = 2;
     */
    id: string;
}
/**
 * @generated from protobuf message databroker.GetResponse
 */
export interface GetResponse {
    /**
     * @generated from protobuf field: databroker.Record record = 1;
     */
    record?: Record;
}
/**
 * @generated from protobuf message databroker.ListTypesResponse
 */
export interface ListTypesResponse {
    /**
     * @generated from protobuf field: repeated string types = 1;
     */
    types: string[];
}
/**
 * @generated from protobuf message databroker.QueryRequest
 */
export interface QueryRequest {
    /**
     * @generated from protobuf field: string type = 1;
     */
    type: string;
    /**
     * @generated from protobuf field: string query = 2;
     */
    query: string;
    /**
     * @generated from protobuf field: int64 offset = 3;
     */
    offset: bigint;
    /**
     * @generated from protobuf field: int64 limit = 4;
     */
    limit: bigint;
    /**
     * @generated from protobuf field: google.protobuf.Struct filter = 5;
     */
    filter?: Struct;
}
/**
 * @generated from protobuf message databroker.QueryResponse
 */
export interface QueryResponse {
    /**
     * @generated from protobuf field: repeated databroker.Record records = 1;
     */
    records: Record[];
    /**
     * @generated from protobuf field: int64 total_count = 2;
     */
    totalCount: bigint;
    /**
     * @generated from protobuf field: uint64 server_version = 3;
     */
    serverVersion: bigint;
    /**
     * @generated from protobuf field: uint64 record_version = 4;
     */
    recordVersion: bigint;
}
/**
 * @generated from protobuf message databroker.PutRequest
 */
export interface PutRequest {
    /**
     * @generated from protobuf field: repeated databroker.Record records = 1;
     */
    records: Record[];
}
/**
 * @generated from protobuf message databroker.PutResponse
 */
export interface PutResponse {
    /**
     * @generated from protobuf field: uint64 server_version = 1;
     */
    serverVersion: bigint;
    /**
     * @generated from protobuf field: repeated databroker.Record records = 2;
     */
    records: Record[];
}
/**
 * @generated from protobuf message databroker.PatchRequest
 */
export interface PatchRequest {
    /**
     * @generated from protobuf field: repeated databroker.Record records = 1;
     */
    records: Record[];
    /**
     * @generated from protobuf field: google.protobuf.FieldMask field_mask = 2;
     */
    fieldMask?: FieldMask;
}
/**
 * @generated from protobuf message databroker.PatchResponse
 */
export interface PatchResponse {
    /**
     * @generated from protobuf field: uint64 server_version = 1;
     */
    serverVersion: bigint;
    /**
     * @generated from protobuf field: repeated databroker.Record records = 2;
     */
    records: Record[];
}
/**
 * @generated from protobuf message databroker.SetOptionsRequest
 */
export interface SetOptionsRequest {
    /**
     * @generated from protobuf field: string type = 1;
     */
    type: string;
    /**
     * @generated from protobuf field: databroker.Options options = 2;
     */
    options?: Options;
}
/**
 * @generated from protobuf message databroker.SetOptionsResponse
 */
export interface SetOptionsResponse {
    /**
     * @generated from protobuf field: databroker.Options options = 1;
     */
    options?: Options;
}
/**
 * @generated from protobuf message databroker.SyncRequest
 */
export interface SyncRequest {
    /**
     * @generated from protobuf field: uint64 server_version = 1;
     */
    serverVersion: bigint;
    /**
     * @generated from protobuf field: uint64 record_version = 2;
     */
    recordVersion: bigint;
    /**
     * @generated from protobuf field: string type = 3;
     */
    type: string;
}
/**
 * @generated from protobuf message databroker.SyncResponse
 */
export interface SyncResponse {
    /**
     * @generated from protobuf field: databroker.Record record = 1;
     */
    record?: Record;
}
/**
 * @generated from protobuf message databroker.SyncLatestRequest
 */
export interface SyncLatestRequest {
    /**
     * @generated from protobuf field: string type = 1;
     */
    type: string;
}
/**
 * @generated from protobuf message databroker.SyncLatestResponse
 */
export interface SyncLatestResponse {
    /**
     * @generated from protobuf oneof: response
     */
    response: {
        oneofKind: "record";
        /**
         * @generated from protobuf field: databroker.Record record = 1;
         */
        record: Record;
    } | {
        oneofKind: "versions";
        /**
         * @generated from protobuf field: databroker.Versions versions = 2;
         */
        versions: Versions;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message databroker.AcquireLeaseRequest
 */
export interface AcquireLeaseRequest {
    /**
     * Name is the name of the lease. Only a single client can hold the lease on
     * the specified name at any one time.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * Duration is the duration of the lease. After the duration is reached the
     * lease can be acquired by other clients.
     *
     * @generated from protobuf field: google.protobuf.Duration duration = 2;
     */
    duration?: Duration;
}
/**
 * @generated from protobuf message databroker.AcquireLeaseResponse
 */
export interface AcquireLeaseResponse {
    /**
     * Id is the id of the acquired lease. Subsequent calls to release or renew
     * will need both the lease name and the lease id.
     *
     * @generated from protobuf field: string id = 1;
     */
    id: string;
}
/**
 * @generated from protobuf message databroker.ReleaseLeaseRequest
 */
export interface ReleaseLeaseRequest {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: string id = 2;
     */
    id: string;
}
/**
 * @generated from protobuf message databroker.RenewLeaseRequest
 */
export interface RenewLeaseRequest {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: string id = 2;
     */
    id: string;
    /**
     * @generated from protobuf field: google.protobuf.Duration duration = 3;
     */
    duration?: Duration;
}
// @generated message type with reflection information, may provide speed optimized methods
class Record$Type extends MessageType<Record> {
    constructor() {
        super("databroker.Record", [
            { no: 1, name: "version", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "data", kind: "message", T: () => Any },
            { no: 5, name: "modified_at", kind: "message", T: () => Timestamp },
            { no: 6, name: "deleted_at", kind: "message", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<Record>): Record {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.version = 0n;
        message.type = "";
        message.id = "";
        if (value !== undefined)
            reflectionMergePartial<Record>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Record): Record {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 version */ 1:
                    message.version = reader.uint64().toBigInt();
                    break;
                case /* string type */ 2:
                    message.type = reader.string();
                    break;
                case /* string id */ 3:
                    message.id = reader.string();
                    break;
                case /* google.protobuf.Any data */ 4:
                    message.data = Any.internalBinaryRead(reader, reader.uint32(), options, message.data);
                    break;
                case /* google.protobuf.Timestamp modified_at */ 5:
                    message.modifiedAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.modifiedAt);
                    break;
                case /* google.protobuf.Timestamp deleted_at */ 6:
                    message.deletedAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.deletedAt);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Record, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 version = 1; */
        if (message.version !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.version);
        /* string type = 2; */
        if (message.type !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.type);
        /* string id = 3; */
        if (message.id !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.id);
        /* google.protobuf.Any data = 4; */
        if (message.data)
            Any.internalBinaryWrite(message.data, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp modified_at = 5; */
        if (message.modifiedAt)
            Timestamp.internalBinaryWrite(message.modifiedAt, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp deleted_at = 6; */
        if (message.deletedAt)
            Timestamp.internalBinaryWrite(message.deletedAt, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message databroker.Record
 */
export const Record = new Record$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Versions$Type extends MessageType<Versions> {
    constructor() {
        super("databroker.Versions", [
            { no: 1, name: "server_version", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "latest_record_version", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<Versions>): Versions {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.serverVersion = 0n;
        message.latestRecordVersion = 0n;
        if (value !== undefined)
            reflectionMergePartial<Versions>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Versions): Versions {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 server_version */ 1:
                    message.serverVersion = reader.uint64().toBigInt();
                    break;
                case /* uint64 latest_record_version */ 2:
                    message.latestRecordVersion = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Versions, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 server_version = 1; */
        if (message.serverVersion !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.serverVersion);
        /* uint64 latest_record_version = 2; */
        if (message.latestRecordVersion !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.latestRecordVersion);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message databroker.Versions
 */
export const Versions = new Versions$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Options$Type extends MessageType<Options> {
    constructor() {
        super("databroker.Options", [
            { no: 1, name: "capacity", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<Options>): Options {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Options>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Options): Options {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint64 capacity */ 1:
                    message.capacity = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Options, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint64 capacity = 1; */
        if (message.capacity !== undefined)
            writer.tag(1, WireType.Varint).uint64(message.capacity);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message databroker.Options
 */
export const Options = new Options$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetRequest$Type extends MessageType<GetRequest> {
    constructor() {
        super("databroker.GetRequest", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetRequest>): GetRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = "";
        message.id = "";
        if (value !== undefined)
            reflectionMergePartial<GetRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetRequest): GetRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* string id */ 2:
                    message.id = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.type);
        /* string id = 2; */
        if (message.id !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message databroker.GetRequest
 */
export const GetRequest = new GetRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetResponse$Type extends MessageType<GetResponse> {
    constructor() {
        super("databroker.GetResponse", [
            { no: 1, name: "record", kind: "message", T: () => Record }
        ]);
    }
    create(value?: PartialMessage<GetResponse>): GetResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetResponse): GetResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* databroker.Record record */ 1:
                    message.record = Record.internalBinaryRead(reader, reader.uint32(), options, message.record);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* databroker.Record record = 1; */
        if (message.record)
            Record.internalBinaryWrite(message.record, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message databroker.GetResponse
 */
export const GetResponse = new GetResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListTypesResponse$Type extends MessageType<ListTypesResponse> {
    constructor() {
        super("databroker.ListTypesResponse", [
            { no: 1, name: "types", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ListTypesResponse>): ListTypesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.types = [];
        if (value !== undefined)
            reflectionMergePartial<ListTypesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListTypesResponse): ListTypesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string types */ 1:
                    message.types.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListTypesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string types = 1; */
        for (let i = 0; i < message.types.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.types[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message databroker.ListTypesResponse
 */
export const ListTypesResponse = new ListTypesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryRequest$Type extends MessageType<QueryRequest> {
    constructor() {
        super("databroker.QueryRequest", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "query", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "offset", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "limit", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "filter", kind: "message", T: () => Struct }
        ]);
    }
    create(value?: PartialMessage<QueryRequest>): QueryRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = "";
        message.query = "";
        message.offset = 0n;
        message.limit = 0n;
        if (value !== undefined)
            reflectionMergePartial<QueryRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryRequest): QueryRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* string query */ 2:
                    message.query = reader.string();
                    break;
                case /* int64 offset */ 3:
                    message.offset = reader.int64().toBigInt();
                    break;
                case /* int64 limit */ 4:
                    message.limit = reader.int64().toBigInt();
                    break;
                case /* google.protobuf.Struct filter */ 5:
                    message.filter = Struct.internalBinaryRead(reader, reader.uint32(), options, message.filter);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.type);
        /* string query = 2; */
        if (message.query !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.query);
        /* int64 offset = 3; */
        if (message.offset !== 0n)
            writer.tag(3, WireType.Varint).int64(message.offset);
        /* int64 limit = 4; */
        if (message.limit !== 0n)
            writer.tag(4, WireType.Varint).int64(message.limit);
        /* google.protobuf.Struct filter = 5; */
        if (message.filter)
            Struct.internalBinaryWrite(message.filter, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message databroker.QueryRequest
 */
export const QueryRequest = new QueryRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryResponse$Type extends MessageType<QueryResponse> {
    constructor() {
        super("databroker.QueryResponse", [
            { no: 1, name: "records", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Record },
            { no: 2, name: "total_count", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "server_version", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "record_version", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<QueryResponse>): QueryResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.records = [];
        message.totalCount = 0n;
        message.serverVersion = 0n;
        message.recordVersion = 0n;
        if (value !== undefined)
            reflectionMergePartial<QueryResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryResponse): QueryResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated databroker.Record records */ 1:
                    message.records.push(Record.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* int64 total_count */ 2:
                    message.totalCount = reader.int64().toBigInt();
                    break;
                case /* uint64 server_version */ 3:
                    message.serverVersion = reader.uint64().toBigInt();
                    break;
                case /* uint64 record_version */ 4:
                    message.recordVersion = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated databroker.Record records = 1; */
        for (let i = 0; i < message.records.length; i++)
            Record.internalBinaryWrite(message.records[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* int64 total_count = 2; */
        if (message.totalCount !== 0n)
            writer.tag(2, WireType.Varint).int64(message.totalCount);
        /* uint64 server_version = 3; */
        if (message.serverVersion !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.serverVersion);
        /* uint64 record_version = 4; */
        if (message.recordVersion !== 0n)
            writer.tag(4, WireType.Varint).uint64(message.recordVersion);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message databroker.QueryResponse
 */
export const QueryResponse = new QueryResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PutRequest$Type extends MessageType<PutRequest> {
    constructor() {
        super("databroker.PutRequest", [
            { no: 1, name: "records", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Record }
        ]);
    }
    create(value?: PartialMessage<PutRequest>): PutRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.records = [];
        if (value !== undefined)
            reflectionMergePartial<PutRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PutRequest): PutRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated databroker.Record records */ 1:
                    message.records.push(Record.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PutRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated databroker.Record records = 1; */
        for (let i = 0; i < message.records.length; i++)
            Record.internalBinaryWrite(message.records[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message databroker.PutRequest
 */
export const PutRequest = new PutRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PutResponse$Type extends MessageType<PutResponse> {
    constructor() {
        super("databroker.PutResponse", [
            { no: 1, name: "server_version", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "records", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Record }
        ]);
    }
    create(value?: PartialMessage<PutResponse>): PutResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.serverVersion = 0n;
        message.records = [];
        if (value !== undefined)
            reflectionMergePartial<PutResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PutResponse): PutResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 server_version */ 1:
                    message.serverVersion = reader.uint64().toBigInt();
                    break;
                case /* repeated databroker.Record records */ 2:
                    message.records.push(Record.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PutResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 server_version = 1; */
        if (message.serverVersion !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.serverVersion);
        /* repeated databroker.Record records = 2; */
        for (let i = 0; i < message.records.length; i++)
            Record.internalBinaryWrite(message.records[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message databroker.PutResponse
 */
export const PutResponse = new PutResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PatchRequest$Type extends MessageType<PatchRequest> {
    constructor() {
        super("databroker.PatchRequest", [
            { no: 1, name: "records", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Record },
            { no: 2, name: "field_mask", kind: "message", T: () => FieldMask }
        ]);
    }
    create(value?: PartialMessage<PatchRequest>): PatchRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.records = [];
        if (value !== undefined)
            reflectionMergePartial<PatchRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PatchRequest): PatchRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated databroker.Record records */ 1:
                    message.records.push(Record.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* google.protobuf.FieldMask field_mask */ 2:
                    message.fieldMask = FieldMask.internalBinaryRead(reader, reader.uint32(), options, message.fieldMask);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PatchRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated databroker.Record records = 1; */
        for (let i = 0; i < message.records.length; i++)
            Record.internalBinaryWrite(message.records[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.FieldMask field_mask = 2; */
        if (message.fieldMask)
            FieldMask.internalBinaryWrite(message.fieldMask, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message databroker.PatchRequest
 */
export const PatchRequest = new PatchRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PatchResponse$Type extends MessageType<PatchResponse> {
    constructor() {
        super("databroker.PatchResponse", [
            { no: 1, name: "server_version", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "records", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Record }
        ]);
    }
    create(value?: PartialMessage<PatchResponse>): PatchResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.serverVersion = 0n;
        message.records = [];
        if (value !== undefined)
            reflectionMergePartial<PatchResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PatchResponse): PatchResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 server_version */ 1:
                    message.serverVersion = reader.uint64().toBigInt();
                    break;
                case /* repeated databroker.Record records */ 2:
                    message.records.push(Record.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PatchResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 server_version = 1; */
        if (message.serverVersion !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.serverVersion);
        /* repeated databroker.Record records = 2; */
        for (let i = 0; i < message.records.length; i++)
            Record.internalBinaryWrite(message.records[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message databroker.PatchResponse
 */
export const PatchResponse = new PatchResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetOptionsRequest$Type extends MessageType<SetOptionsRequest> {
    constructor() {
        super("databroker.SetOptionsRequest", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "options", kind: "message", T: () => Options }
        ]);
    }
    create(value?: PartialMessage<SetOptionsRequest>): SetOptionsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = "";
        if (value !== undefined)
            reflectionMergePartial<SetOptionsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetOptionsRequest): SetOptionsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* databroker.Options options */ 2:
                    message.options = Options.internalBinaryRead(reader, reader.uint32(), options, message.options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetOptionsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.type);
        /* databroker.Options options = 2; */
        if (message.options)
            Options.internalBinaryWrite(message.options, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message databroker.SetOptionsRequest
 */
export const SetOptionsRequest = new SetOptionsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetOptionsResponse$Type extends MessageType<SetOptionsResponse> {
    constructor() {
        super("databroker.SetOptionsResponse", [
            { no: 1, name: "options", kind: "message", T: () => Options }
        ]);
    }
    create(value?: PartialMessage<SetOptionsResponse>): SetOptionsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SetOptionsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetOptionsResponse): SetOptionsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* databroker.Options options */ 1:
                    message.options = Options.internalBinaryRead(reader, reader.uint32(), options, message.options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetOptionsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* databroker.Options options = 1; */
        if (message.options)
            Options.internalBinaryWrite(message.options, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message databroker.SetOptionsResponse
 */
export const SetOptionsResponse = new SetOptionsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SyncRequest$Type extends MessageType<SyncRequest> {
    constructor() {
        super("databroker.SyncRequest", [
            { no: 1, name: "server_version", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "record_version", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SyncRequest>): SyncRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.serverVersion = 0n;
        message.recordVersion = 0n;
        message.type = "";
        if (value !== undefined)
            reflectionMergePartial<SyncRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SyncRequest): SyncRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 server_version */ 1:
                    message.serverVersion = reader.uint64().toBigInt();
                    break;
                case /* uint64 record_version */ 2:
                    message.recordVersion = reader.uint64().toBigInt();
                    break;
                case /* string type */ 3:
                    message.type = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SyncRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 server_version = 1; */
        if (message.serverVersion !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.serverVersion);
        /* uint64 record_version = 2; */
        if (message.recordVersion !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.recordVersion);
        /* string type = 3; */
        if (message.type !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.type);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message databroker.SyncRequest
 */
export const SyncRequest = new SyncRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SyncResponse$Type extends MessageType<SyncResponse> {
    constructor() {
        super("databroker.SyncResponse", [
            { no: 1, name: "record", kind: "message", T: () => Record }
        ]);
    }
    create(value?: PartialMessage<SyncResponse>): SyncResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SyncResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SyncResponse): SyncResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* databroker.Record record */ 1:
                    message.record = Record.internalBinaryRead(reader, reader.uint32(), options, message.record);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SyncResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* databroker.Record record = 1; */
        if (message.record)
            Record.internalBinaryWrite(message.record, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message databroker.SyncResponse
 */
export const SyncResponse = new SyncResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SyncLatestRequest$Type extends MessageType<SyncLatestRequest> {
    constructor() {
        super("databroker.SyncLatestRequest", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SyncLatestRequest>): SyncLatestRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = "";
        if (value !== undefined)
            reflectionMergePartial<SyncLatestRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SyncLatestRequest): SyncLatestRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SyncLatestRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.type);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message databroker.SyncLatestRequest
 */
export const SyncLatestRequest = new SyncLatestRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SyncLatestResponse$Type extends MessageType<SyncLatestResponse> {
    constructor() {
        super("databroker.SyncLatestResponse", [
            { no: 1, name: "record", kind: "message", oneof: "response", T: () => Record },
            { no: 2, name: "versions", kind: "message", oneof: "response", T: () => Versions }
        ]);
    }
    create(value?: PartialMessage<SyncLatestResponse>): SyncLatestResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.response = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<SyncLatestResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SyncLatestResponse): SyncLatestResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* databroker.Record record */ 1:
                    message.response = {
                        oneofKind: "record",
                        record: Record.internalBinaryRead(reader, reader.uint32(), options, (message.response as any).record)
                    };
                    break;
                case /* databroker.Versions versions */ 2:
                    message.response = {
                        oneofKind: "versions",
                        versions: Versions.internalBinaryRead(reader, reader.uint32(), options, (message.response as any).versions)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SyncLatestResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* databroker.Record record = 1; */
        if (message.response.oneofKind === "record")
            Record.internalBinaryWrite(message.response.record, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* databroker.Versions versions = 2; */
        if (message.response.oneofKind === "versions")
            Versions.internalBinaryWrite(message.response.versions, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message databroker.SyncLatestResponse
 */
export const SyncLatestResponse = new SyncLatestResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AcquireLeaseRequest$Type extends MessageType<AcquireLeaseRequest> {
    constructor() {
        super("databroker.AcquireLeaseRequest", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "duration", kind: "message", T: () => Duration }
        ]);
    }
    create(value?: PartialMessage<AcquireLeaseRequest>): AcquireLeaseRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<AcquireLeaseRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AcquireLeaseRequest): AcquireLeaseRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* google.protobuf.Duration duration */ 2:
                    message.duration = Duration.internalBinaryRead(reader, reader.uint32(), options, message.duration);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AcquireLeaseRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* google.protobuf.Duration duration = 2; */
        if (message.duration)
            Duration.internalBinaryWrite(message.duration, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message databroker.AcquireLeaseRequest
 */
export const AcquireLeaseRequest = new AcquireLeaseRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AcquireLeaseResponse$Type extends MessageType<AcquireLeaseResponse> {
    constructor() {
        super("databroker.AcquireLeaseResponse", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<AcquireLeaseResponse>): AcquireLeaseResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        if (value !== undefined)
            reflectionMergePartial<AcquireLeaseResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AcquireLeaseResponse): AcquireLeaseResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AcquireLeaseResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message databroker.AcquireLeaseResponse
 */
export const AcquireLeaseResponse = new AcquireLeaseResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReleaseLeaseRequest$Type extends MessageType<ReleaseLeaseRequest> {
    constructor() {
        super("databroker.ReleaseLeaseRequest", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ReleaseLeaseRequest>): ReleaseLeaseRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.id = "";
        if (value !== undefined)
            reflectionMergePartial<ReleaseLeaseRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReleaseLeaseRequest): ReleaseLeaseRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string id */ 2:
                    message.id = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReleaseLeaseRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string id = 2; */
        if (message.id !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message databroker.ReleaseLeaseRequest
 */
export const ReleaseLeaseRequest = new ReleaseLeaseRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RenewLeaseRequest$Type extends MessageType<RenewLeaseRequest> {
    constructor() {
        super("databroker.RenewLeaseRequest", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "duration", kind: "message", T: () => Duration }
        ]);
    }
    create(value?: PartialMessage<RenewLeaseRequest>): RenewLeaseRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.id = "";
        if (value !== undefined)
            reflectionMergePartial<RenewLeaseRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RenewLeaseRequest): RenewLeaseRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string id */ 2:
                    message.id = reader.string();
                    break;
                case /* google.protobuf.Duration duration */ 3:
                    message.duration = Duration.internalBinaryRead(reader, reader.uint32(), options, message.duration);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RenewLeaseRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string id = 2; */
        if (message.id !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.id);
        /* google.protobuf.Duration duration = 3; */
        if (message.duration)
            Duration.internalBinaryWrite(message.duration, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message databroker.RenewLeaseRequest
 */
export const RenewLeaseRequest = new RenewLeaseRequest$Type();
/**
 * @generated ServiceType for protobuf service databroker.DataBrokerService
 */
export const DataBrokerService = new ServiceType("databroker.DataBrokerService", [
    { name: "AcquireLease", options: {}, I: AcquireLeaseRequest, O: AcquireLeaseResponse },
    { name: "Get", options: {}, I: GetRequest, O: GetResponse },
    { name: "ListTypes", options: {}, I: Empty, O: ListTypesResponse },
    { name: "Put", options: {}, I: PutRequest, O: PutResponse },
    { name: "Patch", options: {}, I: PatchRequest, O: PatchResponse },
    { name: "Query", options: {}, I: QueryRequest, O: QueryResponse },
    { name: "ReleaseLease", options: {}, I: ReleaseLeaseRequest, O: Empty },
    { name: "RenewLease", options: {}, I: RenewLeaseRequest, O: Empty },
    { name: "SetOptions", options: {}, I: SetOptionsRequest, O: SetOptionsResponse },
    { name: "Sync", serverStreaming: true, options: {}, I: SyncRequest, O: SyncResponse },
    { name: "SyncLatest", serverStreaming: true, options: {}, I: SyncLatestRequest, O: SyncLatestResponse }
]);
