// @generated by protobuf-ts 2.9.4 with parameter generate_dependencies
// @generated from protobuf file "tsdb.proto" (package "pomerium.dashboard", syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Duration } from "./google/protobuf/duration";
import { Timestamp } from "./google/protobuf/timestamp";
/**
 * @generated from protobuf message pomerium.dashboard.Range
 */
export interface Range {
    /**
     * Start time
     *
     * @generated from protobuf field: google.protobuf.Timestamp start = 1;
     */
    start?: Timestamp;
    /**
     * End time
     *
     * @generated from protobuf field: google.protobuf.Timestamp end = 2;
     */
    end?: Timestamp;
    /**
     * Max time between two slices within [start:end]
     *
     * @generated from protobuf field: google.protobuf.Duration step = 3;
     */
    step?: Duration;
}
/**
 * RouteMatcher may be used to query data for multiple routes
 *
 * @generated from protobuf message pomerium.dashboard.RouteMatcher
 */
export interface RouteMatcher {
    /**
     * @generated from protobuf oneof: matcher
     */
    matcher: {
        oneofKind: "routeId";
        /**
         * route database ID
         *
         * @generated from protobuf field: string route_id = 1;
         */
        routeId: string;
    } | {
        oneofKind: "namespaceId";
        /**
         * namespace ID
         *
         * @generated from protobuf field: string namespace_id = 2;
         */
        namespaceId: string;
    } | {
        oneofKind: "extDataSourceId";
        /**
         * external data source database ID
         *
         * @generated from protobuf field: string ext_data_source_id = 3;
         */
        extDataSourceId: string;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message pomerium.dashboard.String
 */
export interface String$ {
    /**
     * @generated from protobuf field: string value = 1;
     */
    value: string;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp ts = 2;
     */
    ts?: Timestamp;
}
/**
 * @generated from protobuf message pomerium.dashboard.Scalar
 */
export interface Scalar {
    /**
     * @generated from protobuf field: double value = 1;
     */
    value: number;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp ts = 2;
     */
    ts?: Timestamp;
}
/**
 * @generated from protobuf message pomerium.dashboard.TimeSeries
 */
export interface TimeSeries {
    /**
     * @generated from protobuf field: map<string, string> labels = 1;
     */
    labels: {
        [key: string]: string;
    };
    /**
     * @generated from protobuf field: repeated pomerium.dashboard.Scalar series = 2;
     */
    series: Scalar[];
}
/**
 * @generated from protobuf message pomerium.dashboard.Matrix
 */
export interface Matrix {
    /**
     * @generated from protobuf field: repeated pomerium.dashboard.TimeSeries series = 1;
     */
    series: TimeSeries[];
}
/**
 * @generated from protobuf message pomerium.dashboard.Sample
 */
export interface Sample {
    /**
     * @generated from protobuf field: map<string, string> labels = 1;
     */
    labels: {
        [key: string]: string;
    };
    /**
     * @generated from protobuf field: pomerium.dashboard.Scalar value = 2;
     */
    value?: Scalar;
}
/**
 * @generated from protobuf message pomerium.dashboard.Vector
 */
export interface Vector {
    /**
     * @generated from protobuf field: repeated pomerium.dashboard.Sample samples = 1;
     */
    samples: Sample[];
}
/**
 * request route-specific metric time series
 *
 * @generated from protobuf message pomerium.dashboard.RouteMetricSeriesRequest
 */
export interface RouteMetricSeriesRequest {
    /**
     * route to match
     *
     * @generated from protobuf field: pomerium.dashboard.RouteMatcher matcher = 1;
     */
    matcher?: RouteMatcher;
    /**
     * metric to retrieve
     *
     * @generated from protobuf field: pomerium.dashboard.Metric metric = 2;
     */
    metric: Metric;
    /**
     * time range and sampling step
     *
     * @generated from protobuf field: pomerium.dashboard.Range range = 3;
     */
    range?: Range;
}
/**
 * request route-specific metric time series histogram
 *
 * @generated from protobuf message pomerium.dashboard.RouteMetricSeriesHistogramRequest
 */
export interface RouteMetricSeriesHistogramRequest {
    /**
     * route to match
     *
     * @generated from protobuf field: pomerium.dashboard.RouteMatcher matcher = 1;
     */
    matcher?: RouteMatcher;
    /**
     * metric to retrieve
     *
     * @generated from protobuf field: pomerium.dashboard.Metric metric = 2;
     */
    metric: Metric;
    /**
     * time range and sampling step
     *
     * @generated from protobuf field: pomerium.dashboard.Range range = 3;
     */
    range?: Range;
    /**
     * if data for the metric was precomputed as histogram, the data may be
     * requested within a certain percentile
     *
     * @generated from protobuf field: double percentile = 4;
     */
    percentile: number;
}
/**
 * @generated from protobuf message pomerium.dashboard.ServerMetricSeriesRequest
 */
export interface ServerMetricSeriesRequest {
    /**
     * metric to retrieve
     *
     * @generated from protobuf field: pomerium.dashboard.Metric metric = 2;
     */
    metric: Metric;
    /**
     * time range and sampling step
     *
     * @generated from protobuf field: pomerium.dashboard.Range range = 3;
     */
    range?: Range;
    /**
     * if data for the metric was precomputed as histogram, the data may be
     * requested within a certain percentile
     *
     * @generated from protobuf field: double percentile = 4;
     */
    percentile: number;
    /**
     * server component and instance ID
     *
     * @generated from protobuf field: pomerium.dashboard.Component component = 5;
     */
    component: Component;
    /**
     * @generated from protobuf field: string instance_id = 6;
     */
    instanceId: string;
}
/**
 * @generated from protobuf message pomerium.dashboard.ServerMetricRequest
 */
export interface ServerMetricRequest {
    /**
     * @generated from protobuf field: pomerium.dashboard.Component component = 1;
     */
    component: Component;
    /**
     * @generated from protobuf field: string instance_id = 2;
     */
    instanceId: string;
    /**
     * metric to retrieve
     *
     * @generated from protobuf field: pomerium.dashboard.Metric metric = 3;
     */
    metric: Metric;
}
/**
 * @generated from protobuf message pomerium.dashboard.ConsoleMetricRequest
 */
export interface ConsoleMetricRequest {
    /**
     * @generated from protobuf field: pomerium.dashboard.Metric metric = 1;
     */
    metric: Metric;
}
/**
 * Requests console metric time series
 *
 * @generated from protobuf message pomerium.dashboard.ConsoleMetricSeriesRequest
 */
export interface ConsoleMetricSeriesRequest {
    /**
     * metric to retrieve
     *
     * @generated from protobuf field: pomerium.dashboard.Metric metric = 1;
     */
    metric: Metric;
    /**
     * Start time
     *
     * @generated from protobuf field: google.protobuf.Timestamp start = 2;
     */
    start?: Timestamp;
    /**
     * End time
     *
     * @generated from protobuf field: google.protobuf.Timestamp end = 3;
     */
    end?: Timestamp;
}
/**
 * LastErrorRequest will fetch last known error for certain error-related
 * metrics
 *
 * @generated from protobuf message pomerium.dashboard.LastErrorRequest
 */
export interface LastErrorRequest {
    /**
     * @generated from protobuf field: pomerium.dashboard.Metric metric = 1;
     */
    metric: Metric;
}
/**
 * LastErrorResponse returns last known error for certain error-related metrics
 *
 * @generated from protobuf message pomerium.dashboard.LastErrorResponse
 */
export interface LastErrorResponse {
    /**
     * @generated from protobuf field: google.protobuf.Timestamp ts = 1;
     */
    ts?: Timestamp;
    /**
     * @generated from protobuf field: string message = 2;
     */
    message: string;
}
/**
 * Used to request a particular metric change within a given period of time
 *
 * @generated from protobuf message pomerium.dashboard.RouteMetricChangeRequest
 */
export interface RouteMetricChangeRequest {
    /**
     * route to match
     *
     * @generated from protobuf field: pomerium.dashboard.RouteMatcher matcher = 1;
     */
    matcher?: RouteMatcher;
    /**
     * metric to retrieve
     *
     * @generated from protobuf field: pomerium.dashboard.Metric metric = 2;
     */
    metric: Metric;
    /**
     * Start time
     *
     * @generated from protobuf field: google.protobuf.Timestamp start = 3;
     */
    start?: Timestamp;
    /**
     * End time
     *
     * @generated from protobuf field: google.protobuf.Timestamp end = 4;
     */
    end?: Timestamp;
}
/**
 * TimeSeries response returns
 *
 * @generated from protobuf message pomerium.dashboard.TimeSeriesResponse
 */
export interface TimeSeriesResponse {
    /**
     * provided for time-sampled values - i.e. requests <per second>
     *
     * @generated from protobuf field: pomerium.dashboard.Rate rate = 1;
     */
    rate: Rate;
    /**
     * series are (timestamp,value) data points
     *
     * @generated from protobuf field: repeated pomerium.dashboard.Scalar series = 2;
     */
    series: Scalar[];
}
/**
 * Multiple time series response
 *
 * @generated from protobuf message pomerium.dashboard.TimeSeriesResponseMulti
 */
export interface TimeSeriesResponseMulti {
    /**
     * @generated from protobuf field: pomerium.dashboard.Rate rate = 1;
     */
    rate: Rate;
    /**
     * @generated from protobuf field: repeated pomerium.dashboard.TimeSeries series = 2;
     */
    series: TimeSeries[];
}
/**
 * returns histogram values
 *
 * @generated from protobuf message pomerium.dashboard.ScalarBuckets
 */
export interface ScalarBuckets {
    /**
     * @generated from protobuf field: repeated pomerium.dashboard.ScalarBuckets.Bucket buckets = 1;
     */
    buckets: ScalarBuckets_Bucket[];
}
/**
 * @generated from protobuf message pomerium.dashboard.ScalarBuckets.Bucket
 */
export interface ScalarBuckets_Bucket {
    /**
     * bucket identifier
     *
     * @generated from protobuf field: double less_or_equal_than = 1;
     */
    lessOrEqualThan: number;
    /**
     * occurences for the given bucket
     *
     * @generated from protobuf field: int64 count = 2;
     */
    count: bigint;
}
/**
 * uptime info for all pomerium services for a given period of time
 *
 * @generated from protobuf message pomerium.dashboard.UptimeRequest
 */
export interface UptimeRequest {
    /**
     * @generated from protobuf field: google.protobuf.Timestamp start = 1;
     */
    start?: Timestamp;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp end = 2;
     */
    end?: Timestamp;
    /**
     * @generated from protobuf field: pomerium.dashboard.Component component = 3;
     */
    component: Component;
    /**
     * @generated from protobuf field: string instance_id = 4;
     */
    instanceId: string;
}
/**
 *
 * service uptime is calculated based on liveness probe published by each
 * component it is delivered as 2-level hierarchical periods to make it simple
 * for the UI consumer it does not provide statistics as data representation
 * makes it trivial to calculate depending on the UI requirements
 *
 * @generated from protobuf message pomerium.dashboard.UptimeResponse
 */
export interface UptimeResponse {
    /**
     * @generated from protobuf field: repeated pomerium.dashboard.UptimeResponse.Summary intervals = 1;
     */
    intervals: UptimeResponse_Summary[];
}
/**
 * summary provides a higher level information re health of the component
 *
 * @generated from protobuf message pomerium.dashboard.UptimeResponse.Summary
 */
export interface UptimeResponse_Summary {
    /**
     * @generated from protobuf field: google.protobuf.Timestamp start = 1;
     */
    start?: Timestamp;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp end = 2;
     */
    end?: Timestamp;
    /**
     * aggregate status of the system
     *
     * @generated from protobuf field: pomerium.dashboard.UptimeResponse.Status status = 3;
     */
    status: UptimeResponse_Status;
}
/**
 * @generated from protobuf enum pomerium.dashboard.UptimeResponse.Status
 */
export enum UptimeResponse_Status {
    /**
     * @generated from protobuf enum value: UNDEFINED_STATUS_DO_NOT_USE = 0;
     */
    UNDEFINED_STATUS_DO_NOT_USE = 0,
    /**
     * fully operational
     *
     * @generated from protobuf enum value: LIVE = 1;
     */
    LIVE = 1,
    /**
     * no data is available for the period in the prometheus
     *
     * @generated from protobuf enum value: NO_DATA = 2;
     */
    NO_DATA = 2,
    /**
     * prometheus is up but the scraping instance is down
     *
     * @generated from protobuf enum value: DOWN = 3;
     */
    DOWN = 3
}
/**
 * @generated from protobuf message pomerium.dashboard.GetInstancesRequest
 */
export interface GetInstancesRequest {
    /**
     * @generated from protobuf field: google.protobuf.Timestamp start = 1;
     */
    start?: Timestamp;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp end = 2;
     */
    end?: Timestamp;
}
/**
 * @generated from protobuf message pomerium.dashboard.Instances
 */
export interface Instances {
    /**
     * @generated from protobuf field: repeated pomerium.dashboard.Instances.Instance instances = 1;
     */
    instances: Instances_Instance[];
}
/**
 * @generated from protobuf message pomerium.dashboard.Instances.Instance
 */
export interface Instances_Instance {
    /**
     * @generated from protobuf field: pomerium.dashboard.Component component = 1;
     */
    component: Component;
    /**
     * ID that should be used in requests for metrics
     *
     * @generated from protobuf field: string id = 2;
     */
    id: string;
    /**
     * human readable instance name
     *
     * @generated from protobuf field: string name = 3;
     */
    name: string;
}
/**
 * @generated from protobuf message pomerium.dashboard.GetInstanceInfoRequest
 */
export interface GetInstanceInfoRequest {
    /**
     * @generated from protobuf field: pomerium.dashboard.Component component = 3;
     */
    component: Component;
    /**
     * @generated from protobuf field: string instance_id = 4;
     */
    instanceId: string;
}
/**
 * @generated from protobuf message pomerium.dashboard.GetStatusRequest
 */
export interface GetStatusRequest {
}
/**
 * @generated from protobuf message pomerium.dashboard.GetStatusResponse
 */
export interface GetStatusResponse {
    /**
     * @generated from protobuf field: repeated pomerium.dashboard.GetStatusResponse.Target targets = 1;
     */
    targets: GetStatusResponse_Target[];
    /**
     * @generated from protobuf oneof: status
     */
    status: {
        oneofKind: "ok";
        /**
         * @generated from protobuf field: bool ok = 2;
         */
        ok: boolean;
    } | {
        oneofKind: "lastError";
        /**
         * @generated from protobuf field: string last_error = 3;
         */
        lastError: string;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message pomerium.dashboard.GetStatusResponse.Target
 */
export interface GetStatusResponse_Target {
    /**
     * @generated from protobuf field: string scrape_url = 1;
     */
    scrapeUrl: string;
    /**
     * @generated from protobuf field: string global_url = 2;
     */
    globalUrl: string;
    /**
     * @generated from protobuf field: string last_error = 3;
     */
    lastError: string;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp last_scrape = 4;
     */
    lastScrape?: Timestamp;
    /**
     * @generated from protobuf field: pomerium.dashboard.GetStatusResponse.Target.Health health = 5;
     */
    health: GetStatusResponse_Target_Health;
}
/**
 * @generated from protobuf enum pomerium.dashboard.GetStatusResponse.Target.Health
 */
export enum GetStatusResponse_Target_Health {
    /**
     * @generated from protobuf enum value: TARGET_HEALTH_UNKNOWN = 0;
     */
    TARGET_HEALTH_UNKNOWN = 0,
    /**
     * @generated from protobuf enum value: TARGET_HEALTH_UP = 1;
     */
    TARGET_HEALTH_UP = 1,
    /**
     * @generated from protobuf enum value: TARGET_HEALTH_DOWN = 2;
     */
    TARGET_HEALTH_DOWN = 2
}
/**
 * @generated from protobuf message pomerium.dashboard.UsageReportRequest
 */
export interface UsageReportRequest {
}
/**
 * @generated from protobuf message pomerium.dashboard.UsageReportResponse
 */
export interface UsageReportResponse {
    /**
     * @generated from protobuf field: bytes report = 1;
     */
    report: Uint8Array;
}
/**
 * @generated from protobuf message pomerium.dashboard.Labels
 */
export interface Labels {
    /**
     * @generated from protobuf field: map<string, string> labels = 1;
     */
    labels: {
        [key: string]: string;
    };
}
/**
 * Rate defines time-sampled values
 *
 * @generated from protobuf enum pomerium.dashboard.Rate
 */
export enum Rate {
    /**
     * undefined means this is an actual value that is not sampled
     *
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * value represents <something> per second
     *
     * @generated from protobuf enum value: PER_SECOND = 1;
     */
    PER_SECOND = 1
}
/**
 * see
 * https://www.envoyproxy.io/docs/envoy/latest/configuration/upstream/cluster_manager/cluster_stats
 *
 * @generated from protobuf enum pomerium.dashboard.Metric
 */
export enum Metric {
    /**
     * @generated from protobuf enum value: UNDEFINED_METRIC_DO_NOT_USE = 0;
     */
    UNDEFINED_METRIC_DO_NOT_USE = 0,
    /**
     * request counter
     *
     * @generated from protobuf enum value: REQUESTS = 1;
     */
    REQUESTS = 1,
    /**
     * request rate (per second)
     *
     * @generated from protobuf enum value: REQUESTS_RATE = 2;
     */
    REQUESTS_RATE = 2,
    /**
     * duration of the request in milliseconds - this is a histogram counter and
     * requires percentile
     *
     * @generated from protobuf enum value: REQUESTS_DURATION_MS = 3;
     */
    REQUESTS_DURATION_MS = 3,
    /**
     * returns distribution of response codes
     *
     * @generated from protobuf enum value: RESPONSE_CODES = 4;
     */
    RESPONSE_CODES = 4,
    /**
     * Total responses from the authz filter (note that does not imply that
     * requests were allowed to pass thru)
     *
     * @generated from protobuf enum value: AUTHZ_OK = 20;
     */
    AUTHZ_OK = 20,
    /**
     * Total responses from the authorizations service that were to deny the
     * traffic.
     *
     * @generated from protobuf enum value: AUTHZ_DENIED = 21;
     */
    AUTHZ_DENIED = 21,
    /**
     * Total errors contacting the external service.
     *
     * @generated from protobuf enum value: AUTHZ_ERROR = 22;
     */
    AUTHZ_ERROR = 22,
    /**
     * Total requests that are allowed without calling external services due to
     * the filter is disabled.
     *
     * @generated from protobuf enum value: AUTHZ_DISABLED = 23;
     */
    AUTHZ_DISABLED = 23,
    /**
     * Total requests that were error(s) but were allowed through because of
     * failure_mode_allow set to true.
     *
     * @generated from protobuf enum value: AUTHZ_FAILURE_MODE_ALLOWED = 24;
     */
    AUTHZ_FAILURE_MODE_ALLOWED = 24,
    /**
     * Current cluster healthy total (inclusive of both health checking and
     * outlier detection)
     *
     * @generated from protobuf enum value: MEMBERSHIP_HEALTHY = 30;
     */
    MEMBERSHIP_HEALTHY = 30,
    /**
     * Current cluster degraded total
     *
     * @generated from protobuf enum value: MEMBERSHIP_DEGRADED = 31;
     */
    MEMBERSHIP_DEGRADED = 31,
    /**
     * Current cluster excluded total
     *
     * @generated from protobuf enum value: MEMBERSHIP_EXCLUDED = 32;
     */
    MEMBERSHIP_EXCLUDED = 32,
    /**
     * Current cluster membership total
     *
     * @generated from protobuf enum value: MEMBERSHIP_TOTAL = 33;
     */
    MEMBERSHIP_TOTAL = 33,
    /**
     * bytes received - upstream_cx_rx_bytes_total
     *
     * @generated from protobuf enum value: RX_BYTES = 40;
     */
    RX_BYTES = 40,
    /**
     * bytes sent - upstream_cx_tx_bytes_total
     *
     * @generated from protobuf enum value: TX_BYTES = 41;
     */
    TX_BYTES = 41,
    /**
     * total of rx + tx bytes
     *
     * @generated from protobuf enum value: TOTAL_BYTES = 42;
     */
    TOTAL_BYTES = 42,
    /**
     *
     * system metrics
     *
     * @generated from protobuf enum value: MEMORY_ALLOCATED = 51;
     */
    MEMORY_ALLOCATED = 51,
    /**
     * @generated from protobuf enum value: CPU_USAGE = 52;
     */
    CPU_USAGE = 52,
    /**
     *
     * identity provider specific
     *
     * @generated from protobuf enum value: IDP_LAST_REFRESH_TIMESTAMP = 60;
     */
    IDP_LAST_REFRESH_TIMESTAMP = 60,
    /**
     * @generated from protobuf enum value: IDP_LAST_USER_REFRESH_SUCCESS_TIMESTAMP = 100;
     */
    IDP_LAST_USER_REFRESH_SUCCESS_TIMESTAMP = 100,
    /**
     * @generated from protobuf enum value: IDP_LAST_USER_REFRESH_ERROR_TIMESTAMP = 101;
     */
    IDP_LAST_USER_REFRESH_ERROR_TIMESTAMP = 101,
    /**
     * @generated from protobuf enum value: IDP_LAST_USER_REFRESH_ERROR = 102;
     */
    IDP_LAST_USER_REFRESH_ERROR = 102,
    /**
     * @generated from protobuf enum value: IDP_LAST_USER_REFRESH_SUCCESS = 103;
     */
    IDP_LAST_USER_REFRESH_SUCCESS = 103,
    /**
     * @generated from protobuf enum value: IDP_LAST_USER_GROUP_REFRESH_SUCCESS_TIMESTAMP = 104;
     */
    IDP_LAST_USER_GROUP_REFRESH_SUCCESS_TIMESTAMP = 104,
    /**
     * @generated from protobuf enum value: IDP_LAST_USER_GROUP_REFRESH_ERROR_TIMESTAMP = 105;
     */
    IDP_LAST_USER_GROUP_REFRESH_ERROR_TIMESTAMP = 105,
    /**
     * @generated from protobuf enum value: IDP_LAST_USER_GROUP_REFRESH_ERROR = 106;
     */
    IDP_LAST_USER_GROUP_REFRESH_ERROR = 106,
    /**
     * @generated from protobuf enum value: IDP_LAST_USER_GROUP_REFRESH_SUCCESS = 107;
     */
    IDP_LAST_USER_GROUP_REFRESH_SUCCESS = 107,
    /**
     * @generated from protobuf enum value: IDP_LAST_SESSION_REFRESH_SUCCESS_TIMESTAMP = 108;
     */
    IDP_LAST_SESSION_REFRESH_SUCCESS_TIMESTAMP = 108,
    /**
     * @generated from protobuf enum value: IDP_LAST_SESSION_REFRESH_ERROR_TIMESTAMP = 109;
     */
    IDP_LAST_SESSION_REFRESH_ERROR_TIMESTAMP = 109,
    /**
     * @generated from protobuf enum value: IDP_LAST_SESSION_REFRESH_ERROR = 110;
     */
    IDP_LAST_SESSION_REFRESH_ERROR = 110,
    /**
     * @generated from protobuf enum value: IDP_LAST_SESSION_REFRESH_SUCCESS = 111;
     */
    IDP_LAST_SESSION_REFRESH_SUCCESS = 111,
    /**
     *
     * configuration related
     *
     * @generated from protobuf enum value: CONFIG_LAST_RELOAD_SUCCESS_TIMESTAMP = 70;
     */
    CONFIG_LAST_RELOAD_SUCCESS_TIMESTAMP = 70,
    /**
     * @generated from protobuf enum value: BUILD_INFO = 71;
     */
    BUILD_INFO = 71,
    /**
     * @generated from protobuf enum value: CONFIG_CHECKSUM_LOCAL = 72;
     */
    CONFIG_CHECKSUM_LOCAL = 72,
    /**
     * @generated from protobuf enum value: CONFIG_CHECKSUM_DATABROKER = 73;
     */
    CONFIG_CHECKSUM_DATABROKER = 73,
    /**
     * @generated from protobuf enum value: CONFIG_VERSION = 74;
     */
    CONFIG_VERSION = 74,
    /**
     * @generated from protobuf enum value: CONFIG_ERRORS = 75;
     */
    CONFIG_ERRORS = 75,
    /**
     * @generated from protobuf enum value: CONFIG_CONSOLE_VERSION = 76;
     */
    CONFIG_CONSOLE_VERSION = 76,
    /**
     * prometheus metrics
     *
     * @generated from protobuf enum value: PROMETHEUS_STORAGE_BYTES = 80;
     */
    PROMETHEUS_STORAGE_BYTES = 80,
    /**
     * console metrics
     *
     * @generated from protobuf enum value: MONTHLY_ACTIVE_USERS_THRESHOLD = 90;
     */
    MONTHLY_ACTIVE_USERS_THRESHOLD = 90,
    /**
     * @generated from protobuf enum value: MONTHLY_ACTIVE_USERS = 91;
     */
    MONTHLY_ACTIVE_USERS = 91,
    /**
     * http requests completed (not necessarily with code=200)
     *
     * @generated from protobuf enum value: HTTP_REQUESTS_COMPLETED = 120;
     */
    HTTP_REQUESTS_COMPLETED = 120,
    /**
     * http requests failed due to network or dns error
     *
     * @generated from protobuf enum value: HTTP_REQUESTS_FAILED = 121;
     */
    HTTP_REQUESTS_FAILED = 121,
    /**
     * http requests successfully completed (with code=200 or 304 (unchanged))
     *
     * @generated from protobuf enum value: HTTP_REQUESTS_SUCCESS = 122;
     */
    HTTP_REQUESTS_SUCCESS = 122,
    /**
     * http requests either failed or having codes that are not 200 or 304
     *
     * @generated from protobuf enum value: HTTP_REQUESTS_ERROR = 123;
     */
    HTTP_REQUESTS_ERROR = 123,
    /**
     * http average response body size in bytes
     *
     * @generated from protobuf enum value: HTTP_AVG_RESPONSE_SIZE_BYTES = 124;
     */
    HTTP_AVG_RESPONSE_SIZE_BYTES = 124
}
/**
 * @generated from protobuf enum pomerium.dashboard.Component
 */
export enum Component {
    /**
     * @generated from protobuf enum value: UNKNOWN_DO_NOT_USE = 0;
     */
    UNKNOWN_DO_NOT_USE = 0,
    /**
     * @generated from protobuf enum value: AUTHENTICATE = 1;
     */
    AUTHENTICATE = 1,
    /**
     * @generated from protobuf enum value: AUTHORIZE = 2;
     */
    AUTHORIZE = 2,
    /**
     * @generated from protobuf enum value: DATABROKER = 3;
     */
    DATABROKER = 3,
    /**
     * @generated from protobuf enum value: CONSOLE = 4;
     */
    CONSOLE = 4,
    /**
     * @generated from protobuf enum value: PROXY = 5;
     */
    PROXY = 5,
    /**
     * used when all components are running in the all-in-one mode
     *
     * @generated from protobuf enum value: ALL_IN_ONE = 6;
     */
    ALL_IN_ONE = 6,
    /**
     * Proxy envoy is always reported separately
     *
     * @generated from protobuf enum value: PROXY_ENVOY = 7;
     */
    PROXY_ENVOY = 7,
    /**
     * @generated from protobuf enum value: PROMETHEUS = 8;
     */
    PROMETHEUS = 8
}
// @generated message type with reflection information, may provide speed optimized methods
class Range$Type extends MessageType<Range> {
    constructor() {
        super("pomerium.dashboard.Range", [
            { no: 1, name: "start", kind: "message", T: () => Timestamp, options: { "validate.rules": { timestamp: { required: true } } } },
            { no: 2, name: "end", kind: "message", T: () => Timestamp, options: { "validate.rules": { timestamp: { required: true } } } },
            { no: 3, name: "step", kind: "message", T: () => Duration, options: { "validate.rules": { duration: { required: true } } } }
        ]);
    }
    create(value?: PartialMessage<Range>): Range {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Range>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Range): Range {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.Timestamp start */ 1:
                    message.start = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.start);
                    break;
                case /* google.protobuf.Timestamp end */ 2:
                    message.end = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.end);
                    break;
                case /* google.protobuf.Duration step */ 3:
                    message.step = Duration.internalBinaryRead(reader, reader.uint32(), options, message.step);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Range, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.Timestamp start = 1; */
        if (message.start)
            Timestamp.internalBinaryWrite(message.start, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp end = 2; */
        if (message.end)
            Timestamp.internalBinaryWrite(message.end, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Duration step = 3; */
        if (message.step)
            Duration.internalBinaryWrite(message.step, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pomerium.dashboard.Range
 */
export const Range = new Range$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RouteMatcher$Type extends MessageType<RouteMatcher> {
    constructor() {
        super("pomerium.dashboard.RouteMatcher", [
            { no: 1, name: "route_id", kind: "scalar", oneof: "matcher", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 2, name: "namespace_id", kind: "scalar", oneof: "matcher", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 3, name: "ext_data_source_id", kind: "scalar", oneof: "matcher", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } }
        ]);
    }
    create(value?: PartialMessage<RouteMatcher>): RouteMatcher {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.matcher = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<RouteMatcher>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RouteMatcher): RouteMatcher {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string route_id */ 1:
                    message.matcher = {
                        oneofKind: "routeId",
                        routeId: reader.string()
                    };
                    break;
                case /* string namespace_id */ 2:
                    message.matcher = {
                        oneofKind: "namespaceId",
                        namespaceId: reader.string()
                    };
                    break;
                case /* string ext_data_source_id */ 3:
                    message.matcher = {
                        oneofKind: "extDataSourceId",
                        extDataSourceId: reader.string()
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RouteMatcher, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string route_id = 1; */
        if (message.matcher.oneofKind === "routeId")
            writer.tag(1, WireType.LengthDelimited).string(message.matcher.routeId);
        /* string namespace_id = 2; */
        if (message.matcher.oneofKind === "namespaceId")
            writer.tag(2, WireType.LengthDelimited).string(message.matcher.namespaceId);
        /* string ext_data_source_id = 3; */
        if (message.matcher.oneofKind === "extDataSourceId")
            writer.tag(3, WireType.LengthDelimited).string(message.matcher.extDataSourceId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pomerium.dashboard.RouteMatcher
 */
export const RouteMatcher = new RouteMatcher$Type();
// @generated message type with reflection information, may provide speed optimized methods
class String$$Type extends MessageType<String$> {
    constructor() {
        super("pomerium.dashboard.String", [
            { no: 1, name: "value", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "ts", kind: "message", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<String$>): String$ {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.value = "";
        if (value !== undefined)
            reflectionMergePartial<String$>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: String$): String$ {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string value */ 1:
                    message.value = reader.string();
                    break;
                case /* google.protobuf.Timestamp ts */ 2:
                    message.ts = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.ts);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: String$, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string value = 1; */
        if (message.value !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.value);
        /* google.protobuf.Timestamp ts = 2; */
        if (message.ts)
            Timestamp.internalBinaryWrite(message.ts, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pomerium.dashboard.String
 */
export const String$ = new String$$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Scalar$Type extends MessageType<Scalar> {
    constructor() {
        super("pomerium.dashboard.Scalar", [
            { no: 1, name: "value", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 2, name: "ts", kind: "message", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<Scalar>): Scalar {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.value = 0;
        if (value !== undefined)
            reflectionMergePartial<Scalar>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Scalar): Scalar {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double value */ 1:
                    message.value = reader.double();
                    break;
                case /* google.protobuf.Timestamp ts */ 2:
                    message.ts = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.ts);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Scalar, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* double value = 1; */
        if (message.value !== 0)
            writer.tag(1, WireType.Bit64).double(message.value);
        /* google.protobuf.Timestamp ts = 2; */
        if (message.ts)
            Timestamp.internalBinaryWrite(message.ts, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pomerium.dashboard.Scalar
 */
export const Scalar = new Scalar$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TimeSeries$Type extends MessageType<TimeSeries> {
    constructor() {
        super("pomerium.dashboard.TimeSeries", [
            { no: 1, name: "labels", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } },
            { no: 2, name: "series", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Scalar }
        ]);
    }
    create(value?: PartialMessage<TimeSeries>): TimeSeries {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.labels = {};
        message.series = [];
        if (value !== undefined)
            reflectionMergePartial<TimeSeries>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TimeSeries): TimeSeries {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, string> labels */ 1:
                    this.binaryReadMap1(message.labels, reader, options);
                    break;
                case /* repeated pomerium.dashboard.Scalar series */ 2:
                    message.series.push(Scalar.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: TimeSeries["labels"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TimeSeries["labels"] | undefined, val: TimeSeries["labels"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field pomerium.dashboard.TimeSeries.labels");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: TimeSeries, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, string> labels = 1; */
        for (let k of globalThis.Object.keys(message.labels))
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.labels[k]).join();
        /* repeated pomerium.dashboard.Scalar series = 2; */
        for (let i = 0; i < message.series.length; i++)
            Scalar.internalBinaryWrite(message.series[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pomerium.dashboard.TimeSeries
 */
export const TimeSeries = new TimeSeries$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Matrix$Type extends MessageType<Matrix> {
    constructor() {
        super("pomerium.dashboard.Matrix", [
            { no: 1, name: "series", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => TimeSeries }
        ]);
    }
    create(value?: PartialMessage<Matrix>): Matrix {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.series = [];
        if (value !== undefined)
            reflectionMergePartial<Matrix>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Matrix): Matrix {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated pomerium.dashboard.TimeSeries series */ 1:
                    message.series.push(TimeSeries.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Matrix, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated pomerium.dashboard.TimeSeries series = 1; */
        for (let i = 0; i < message.series.length; i++)
            TimeSeries.internalBinaryWrite(message.series[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pomerium.dashboard.Matrix
 */
export const Matrix = new Matrix$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Sample$Type extends MessageType<Sample> {
    constructor() {
        super("pomerium.dashboard.Sample", [
            { no: 1, name: "labels", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } },
            { no: 2, name: "value", kind: "message", T: () => Scalar }
        ]);
    }
    create(value?: PartialMessage<Sample>): Sample {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.labels = {};
        if (value !== undefined)
            reflectionMergePartial<Sample>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Sample): Sample {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, string> labels */ 1:
                    this.binaryReadMap1(message.labels, reader, options);
                    break;
                case /* pomerium.dashboard.Scalar value */ 2:
                    message.value = Scalar.internalBinaryRead(reader, reader.uint32(), options, message.value);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: Sample["labels"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof Sample["labels"] | undefined, val: Sample["labels"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field pomerium.dashboard.Sample.labels");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: Sample, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, string> labels = 1; */
        for (let k of globalThis.Object.keys(message.labels))
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.labels[k]).join();
        /* pomerium.dashboard.Scalar value = 2; */
        if (message.value)
            Scalar.internalBinaryWrite(message.value, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pomerium.dashboard.Sample
 */
export const Sample = new Sample$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Vector$Type extends MessageType<Vector> {
    constructor() {
        super("pomerium.dashboard.Vector", [
            { no: 1, name: "samples", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Sample }
        ]);
    }
    create(value?: PartialMessage<Vector>): Vector {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.samples = [];
        if (value !== undefined)
            reflectionMergePartial<Vector>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Vector): Vector {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated pomerium.dashboard.Sample samples */ 1:
                    message.samples.push(Sample.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Vector, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated pomerium.dashboard.Sample samples = 1; */
        for (let i = 0; i < message.samples.length; i++)
            Sample.internalBinaryWrite(message.samples[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pomerium.dashboard.Vector
 */
export const Vector = new Vector$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RouteMetricSeriesRequest$Type extends MessageType<RouteMetricSeriesRequest> {
    constructor() {
        super("pomerium.dashboard.RouteMetricSeriesRequest", [
            { no: 1, name: "matcher", kind: "message", T: () => RouteMatcher, options: { "validate.rules": { message: { required: true } } } },
            { no: 2, name: "metric", kind: "enum", T: () => ["pomerium.dashboard.Metric", Metric], options: { "validate.rules": { enum: { definedOnly: true, notIn: [0] } } } },
            { no: 3, name: "range", kind: "message", T: () => Range, options: { "validate.rules": { message: { required: true } } } }
        ]);
    }
    create(value?: PartialMessage<RouteMetricSeriesRequest>): RouteMetricSeriesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.metric = 0;
        if (value !== undefined)
            reflectionMergePartial<RouteMetricSeriesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RouteMetricSeriesRequest): RouteMetricSeriesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* pomerium.dashboard.RouteMatcher matcher */ 1:
                    message.matcher = RouteMatcher.internalBinaryRead(reader, reader.uint32(), options, message.matcher);
                    break;
                case /* pomerium.dashboard.Metric metric */ 2:
                    message.metric = reader.int32();
                    break;
                case /* pomerium.dashboard.Range range */ 3:
                    message.range = Range.internalBinaryRead(reader, reader.uint32(), options, message.range);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RouteMetricSeriesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* pomerium.dashboard.RouteMatcher matcher = 1; */
        if (message.matcher)
            RouteMatcher.internalBinaryWrite(message.matcher, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* pomerium.dashboard.Metric metric = 2; */
        if (message.metric !== 0)
            writer.tag(2, WireType.Varint).int32(message.metric);
        /* pomerium.dashboard.Range range = 3; */
        if (message.range)
            Range.internalBinaryWrite(message.range, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pomerium.dashboard.RouteMetricSeriesRequest
 */
export const RouteMetricSeriesRequest = new RouteMetricSeriesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RouteMetricSeriesHistogramRequest$Type extends MessageType<RouteMetricSeriesHistogramRequest> {
    constructor() {
        super("pomerium.dashboard.RouteMetricSeriesHistogramRequest", [
            { no: 1, name: "matcher", kind: "message", T: () => RouteMatcher, options: { "validate.rules": { message: { required: true } } } },
            { no: 2, name: "metric", kind: "enum", T: () => ["pomerium.dashboard.Metric", Metric], options: { "validate.rules": { enum: { definedOnly: true, notIn: [0] } } } },
            { no: 3, name: "range", kind: "message", T: () => Range, options: { "validate.rules": { message: { required: true } } } },
            { no: 4, name: "percentile", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/, options: { "validate.rules": { double: { lte: 1, gte: 0 } } } }
        ]);
    }
    create(value?: PartialMessage<RouteMetricSeriesHistogramRequest>): RouteMetricSeriesHistogramRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.metric = 0;
        message.percentile = 0;
        if (value !== undefined)
            reflectionMergePartial<RouteMetricSeriesHistogramRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RouteMetricSeriesHistogramRequest): RouteMetricSeriesHistogramRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* pomerium.dashboard.RouteMatcher matcher */ 1:
                    message.matcher = RouteMatcher.internalBinaryRead(reader, reader.uint32(), options, message.matcher);
                    break;
                case /* pomerium.dashboard.Metric metric */ 2:
                    message.metric = reader.int32();
                    break;
                case /* pomerium.dashboard.Range range */ 3:
                    message.range = Range.internalBinaryRead(reader, reader.uint32(), options, message.range);
                    break;
                case /* double percentile */ 4:
                    message.percentile = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RouteMetricSeriesHistogramRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* pomerium.dashboard.RouteMatcher matcher = 1; */
        if (message.matcher)
            RouteMatcher.internalBinaryWrite(message.matcher, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* pomerium.dashboard.Metric metric = 2; */
        if (message.metric !== 0)
            writer.tag(2, WireType.Varint).int32(message.metric);
        /* pomerium.dashboard.Range range = 3; */
        if (message.range)
            Range.internalBinaryWrite(message.range, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* double percentile = 4; */
        if (message.percentile !== 0)
            writer.tag(4, WireType.Bit64).double(message.percentile);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pomerium.dashboard.RouteMetricSeriesHistogramRequest
 */
export const RouteMetricSeriesHistogramRequest = new RouteMetricSeriesHistogramRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ServerMetricSeriesRequest$Type extends MessageType<ServerMetricSeriesRequest> {
    constructor() {
        super("pomerium.dashboard.ServerMetricSeriesRequest", [
            { no: 2, name: "metric", kind: "enum", T: () => ["pomerium.dashboard.Metric", Metric], options: { "validate.rules": { enum: { definedOnly: true, notIn: [0] } } } },
            { no: 3, name: "range", kind: "message", T: () => Range, options: { "validate.rules": { message: { required: true } } } },
            { no: 4, name: "percentile", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/, options: { "validate.rules": { double: { lte: 1, gte: 0 } } } },
            { no: 5, name: "component", kind: "enum", T: () => ["pomerium.dashboard.Component", Component], options: { "validate.rules": { enum: { definedOnly: true, notIn: [0] } } } },
            { no: 6, name: "instance_id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } }
        ]);
    }
    create(value?: PartialMessage<ServerMetricSeriesRequest>): ServerMetricSeriesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.metric = 0;
        message.percentile = 0;
        message.component = 0;
        message.instanceId = "";
        if (value !== undefined)
            reflectionMergePartial<ServerMetricSeriesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ServerMetricSeriesRequest): ServerMetricSeriesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* pomerium.dashboard.Metric metric */ 2:
                    message.metric = reader.int32();
                    break;
                case /* pomerium.dashboard.Range range */ 3:
                    message.range = Range.internalBinaryRead(reader, reader.uint32(), options, message.range);
                    break;
                case /* double percentile */ 4:
                    message.percentile = reader.double();
                    break;
                case /* pomerium.dashboard.Component component */ 5:
                    message.component = reader.int32();
                    break;
                case /* string instance_id */ 6:
                    message.instanceId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ServerMetricSeriesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* pomerium.dashboard.Metric metric = 2; */
        if (message.metric !== 0)
            writer.tag(2, WireType.Varint).int32(message.metric);
        /* pomerium.dashboard.Range range = 3; */
        if (message.range)
            Range.internalBinaryWrite(message.range, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* double percentile = 4; */
        if (message.percentile !== 0)
            writer.tag(4, WireType.Bit64).double(message.percentile);
        /* pomerium.dashboard.Component component = 5; */
        if (message.component !== 0)
            writer.tag(5, WireType.Varint).int32(message.component);
        /* string instance_id = 6; */
        if (message.instanceId !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.instanceId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pomerium.dashboard.ServerMetricSeriesRequest
 */
export const ServerMetricSeriesRequest = new ServerMetricSeriesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ServerMetricRequest$Type extends MessageType<ServerMetricRequest> {
    constructor() {
        super("pomerium.dashboard.ServerMetricRequest", [
            { no: 1, name: "component", kind: "enum", T: () => ["pomerium.dashboard.Component", Component], options: { "validate.rules": { enum: { definedOnly: true, notIn: [0] } } } },
            { no: 2, name: "instance_id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 3, name: "metric", kind: "enum", T: () => ["pomerium.dashboard.Metric", Metric], options: { "validate.rules": { enum: { definedOnly: true, notIn: [0] } } } }
        ]);
    }
    create(value?: PartialMessage<ServerMetricRequest>): ServerMetricRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.component = 0;
        message.instanceId = "";
        message.metric = 0;
        if (value !== undefined)
            reflectionMergePartial<ServerMetricRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ServerMetricRequest): ServerMetricRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* pomerium.dashboard.Component component */ 1:
                    message.component = reader.int32();
                    break;
                case /* string instance_id */ 2:
                    message.instanceId = reader.string();
                    break;
                case /* pomerium.dashboard.Metric metric */ 3:
                    message.metric = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ServerMetricRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* pomerium.dashboard.Component component = 1; */
        if (message.component !== 0)
            writer.tag(1, WireType.Varint).int32(message.component);
        /* string instance_id = 2; */
        if (message.instanceId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.instanceId);
        /* pomerium.dashboard.Metric metric = 3; */
        if (message.metric !== 0)
            writer.tag(3, WireType.Varint).int32(message.metric);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pomerium.dashboard.ServerMetricRequest
 */
export const ServerMetricRequest = new ServerMetricRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ConsoleMetricRequest$Type extends MessageType<ConsoleMetricRequest> {
    constructor() {
        super("pomerium.dashboard.ConsoleMetricRequest", [
            { no: 1, name: "metric", kind: "enum", T: () => ["pomerium.dashboard.Metric", Metric], options: { "validate.rules": { enum: { definedOnly: true, notIn: [0] } } } }
        ]);
    }
    create(value?: PartialMessage<ConsoleMetricRequest>): ConsoleMetricRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.metric = 0;
        if (value !== undefined)
            reflectionMergePartial<ConsoleMetricRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ConsoleMetricRequest): ConsoleMetricRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* pomerium.dashboard.Metric metric */ 1:
                    message.metric = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ConsoleMetricRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* pomerium.dashboard.Metric metric = 1; */
        if (message.metric !== 0)
            writer.tag(1, WireType.Varint).int32(message.metric);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pomerium.dashboard.ConsoleMetricRequest
 */
export const ConsoleMetricRequest = new ConsoleMetricRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ConsoleMetricSeriesRequest$Type extends MessageType<ConsoleMetricSeriesRequest> {
    constructor() {
        super("pomerium.dashboard.ConsoleMetricSeriesRequest", [
            { no: 1, name: "metric", kind: "enum", T: () => ["pomerium.dashboard.Metric", Metric], options: { "validate.rules": { enum: { definedOnly: true, notIn: [0] } } } },
            { no: 2, name: "start", kind: "message", T: () => Timestamp, options: { "validate.rules": { timestamp: { required: true } } } },
            { no: 3, name: "end", kind: "message", T: () => Timestamp, options: { "validate.rules": { timestamp: { required: true } } } }
        ]);
    }
    create(value?: PartialMessage<ConsoleMetricSeriesRequest>): ConsoleMetricSeriesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.metric = 0;
        if (value !== undefined)
            reflectionMergePartial<ConsoleMetricSeriesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ConsoleMetricSeriesRequest): ConsoleMetricSeriesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* pomerium.dashboard.Metric metric */ 1:
                    message.metric = reader.int32();
                    break;
                case /* google.protobuf.Timestamp start */ 2:
                    message.start = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.start);
                    break;
                case /* google.protobuf.Timestamp end */ 3:
                    message.end = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.end);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ConsoleMetricSeriesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* pomerium.dashboard.Metric metric = 1; */
        if (message.metric !== 0)
            writer.tag(1, WireType.Varint).int32(message.metric);
        /* google.protobuf.Timestamp start = 2; */
        if (message.start)
            Timestamp.internalBinaryWrite(message.start, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp end = 3; */
        if (message.end)
            Timestamp.internalBinaryWrite(message.end, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pomerium.dashboard.ConsoleMetricSeriesRequest
 */
export const ConsoleMetricSeriesRequest = new ConsoleMetricSeriesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LastErrorRequest$Type extends MessageType<LastErrorRequest> {
    constructor() {
        super("pomerium.dashboard.LastErrorRequest", [
            { no: 1, name: "metric", kind: "enum", T: () => ["pomerium.dashboard.Metric", Metric], options: { "validate.rules": { enum: { definedOnly: true, notIn: [0] } } } }
        ]);
    }
    create(value?: PartialMessage<LastErrorRequest>): LastErrorRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.metric = 0;
        if (value !== undefined)
            reflectionMergePartial<LastErrorRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LastErrorRequest): LastErrorRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* pomerium.dashboard.Metric metric */ 1:
                    message.metric = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LastErrorRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* pomerium.dashboard.Metric metric = 1; */
        if (message.metric !== 0)
            writer.tag(1, WireType.Varint).int32(message.metric);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pomerium.dashboard.LastErrorRequest
 */
export const LastErrorRequest = new LastErrorRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LastErrorResponse$Type extends MessageType<LastErrorResponse> {
    constructor() {
        super("pomerium.dashboard.LastErrorResponse", [
            { no: 1, name: "ts", kind: "message", T: () => Timestamp },
            { no: 2, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<LastErrorResponse>): LastErrorResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.message = "";
        if (value !== undefined)
            reflectionMergePartial<LastErrorResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LastErrorResponse): LastErrorResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.Timestamp ts */ 1:
                    message.ts = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.ts);
                    break;
                case /* string message */ 2:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LastErrorResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.Timestamp ts = 1; */
        if (message.ts)
            Timestamp.internalBinaryWrite(message.ts, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string message = 2; */
        if (message.message !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pomerium.dashboard.LastErrorResponse
 */
export const LastErrorResponse = new LastErrorResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RouteMetricChangeRequest$Type extends MessageType<RouteMetricChangeRequest> {
    constructor() {
        super("pomerium.dashboard.RouteMetricChangeRequest", [
            { no: 1, name: "matcher", kind: "message", T: () => RouteMatcher, options: { "validate.rules": { message: { required: true } } } },
            { no: 2, name: "metric", kind: "enum", T: () => ["pomerium.dashboard.Metric", Metric], options: { "validate.rules": { enum: { definedOnly: true } } } },
            { no: 3, name: "start", kind: "message", T: () => Timestamp, options: { "validate.rules": { timestamp: { required: true } } } },
            { no: 4, name: "end", kind: "message", T: () => Timestamp, options: { "validate.rules": { timestamp: { required: true } } } }
        ]);
    }
    create(value?: PartialMessage<RouteMetricChangeRequest>): RouteMetricChangeRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.metric = 0;
        if (value !== undefined)
            reflectionMergePartial<RouteMetricChangeRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RouteMetricChangeRequest): RouteMetricChangeRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* pomerium.dashboard.RouteMatcher matcher */ 1:
                    message.matcher = RouteMatcher.internalBinaryRead(reader, reader.uint32(), options, message.matcher);
                    break;
                case /* pomerium.dashboard.Metric metric */ 2:
                    message.metric = reader.int32();
                    break;
                case /* google.protobuf.Timestamp start */ 3:
                    message.start = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.start);
                    break;
                case /* google.protobuf.Timestamp end */ 4:
                    message.end = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.end);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RouteMetricChangeRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* pomerium.dashboard.RouteMatcher matcher = 1; */
        if (message.matcher)
            RouteMatcher.internalBinaryWrite(message.matcher, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* pomerium.dashboard.Metric metric = 2; */
        if (message.metric !== 0)
            writer.tag(2, WireType.Varint).int32(message.metric);
        /* google.protobuf.Timestamp start = 3; */
        if (message.start)
            Timestamp.internalBinaryWrite(message.start, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp end = 4; */
        if (message.end)
            Timestamp.internalBinaryWrite(message.end, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pomerium.dashboard.RouteMetricChangeRequest
 */
export const RouteMetricChangeRequest = new RouteMetricChangeRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TimeSeriesResponse$Type extends MessageType<TimeSeriesResponse> {
    constructor() {
        super("pomerium.dashboard.TimeSeriesResponse", [
            { no: 1, name: "rate", kind: "enum", T: () => ["pomerium.dashboard.Rate", Rate] },
            { no: 2, name: "series", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Scalar }
        ]);
    }
    create(value?: PartialMessage<TimeSeriesResponse>): TimeSeriesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.rate = 0;
        message.series = [];
        if (value !== undefined)
            reflectionMergePartial<TimeSeriesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TimeSeriesResponse): TimeSeriesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* pomerium.dashboard.Rate rate */ 1:
                    message.rate = reader.int32();
                    break;
                case /* repeated pomerium.dashboard.Scalar series */ 2:
                    message.series.push(Scalar.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TimeSeriesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* pomerium.dashboard.Rate rate = 1; */
        if (message.rate !== 0)
            writer.tag(1, WireType.Varint).int32(message.rate);
        /* repeated pomerium.dashboard.Scalar series = 2; */
        for (let i = 0; i < message.series.length; i++)
            Scalar.internalBinaryWrite(message.series[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pomerium.dashboard.TimeSeriesResponse
 */
export const TimeSeriesResponse = new TimeSeriesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TimeSeriesResponseMulti$Type extends MessageType<TimeSeriesResponseMulti> {
    constructor() {
        super("pomerium.dashboard.TimeSeriesResponseMulti", [
            { no: 1, name: "rate", kind: "enum", T: () => ["pomerium.dashboard.Rate", Rate] },
            { no: 2, name: "series", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => TimeSeries }
        ]);
    }
    create(value?: PartialMessage<TimeSeriesResponseMulti>): TimeSeriesResponseMulti {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.rate = 0;
        message.series = [];
        if (value !== undefined)
            reflectionMergePartial<TimeSeriesResponseMulti>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TimeSeriesResponseMulti): TimeSeriesResponseMulti {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* pomerium.dashboard.Rate rate */ 1:
                    message.rate = reader.int32();
                    break;
                case /* repeated pomerium.dashboard.TimeSeries series */ 2:
                    message.series.push(TimeSeries.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TimeSeriesResponseMulti, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* pomerium.dashboard.Rate rate = 1; */
        if (message.rate !== 0)
            writer.tag(1, WireType.Varint).int32(message.rate);
        /* repeated pomerium.dashboard.TimeSeries series = 2; */
        for (let i = 0; i < message.series.length; i++)
            TimeSeries.internalBinaryWrite(message.series[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pomerium.dashboard.TimeSeriesResponseMulti
 */
export const TimeSeriesResponseMulti = new TimeSeriesResponseMulti$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ScalarBuckets$Type extends MessageType<ScalarBuckets> {
    constructor() {
        super("pomerium.dashboard.ScalarBuckets", [
            { no: 1, name: "buckets", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ScalarBuckets_Bucket }
        ]);
    }
    create(value?: PartialMessage<ScalarBuckets>): ScalarBuckets {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.buckets = [];
        if (value !== undefined)
            reflectionMergePartial<ScalarBuckets>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ScalarBuckets): ScalarBuckets {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated pomerium.dashboard.ScalarBuckets.Bucket buckets */ 1:
                    message.buckets.push(ScalarBuckets_Bucket.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ScalarBuckets, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated pomerium.dashboard.ScalarBuckets.Bucket buckets = 1; */
        for (let i = 0; i < message.buckets.length; i++)
            ScalarBuckets_Bucket.internalBinaryWrite(message.buckets[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pomerium.dashboard.ScalarBuckets
 */
export const ScalarBuckets = new ScalarBuckets$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ScalarBuckets_Bucket$Type extends MessageType<ScalarBuckets_Bucket> {
    constructor() {
        super("pomerium.dashboard.ScalarBuckets.Bucket", [
            { no: 1, name: "less_or_equal_than", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 2, name: "count", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<ScalarBuckets_Bucket>): ScalarBuckets_Bucket {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.lessOrEqualThan = 0;
        message.count = 0n;
        if (value !== undefined)
            reflectionMergePartial<ScalarBuckets_Bucket>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ScalarBuckets_Bucket): ScalarBuckets_Bucket {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double less_or_equal_than */ 1:
                    message.lessOrEqualThan = reader.double();
                    break;
                case /* int64 count */ 2:
                    message.count = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ScalarBuckets_Bucket, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* double less_or_equal_than = 1; */
        if (message.lessOrEqualThan !== 0)
            writer.tag(1, WireType.Bit64).double(message.lessOrEqualThan);
        /* int64 count = 2; */
        if (message.count !== 0n)
            writer.tag(2, WireType.Varint).int64(message.count);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pomerium.dashboard.ScalarBuckets.Bucket
 */
export const ScalarBuckets_Bucket = new ScalarBuckets_Bucket$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UptimeRequest$Type extends MessageType<UptimeRequest> {
    constructor() {
        super("pomerium.dashboard.UptimeRequest", [
            { no: 1, name: "start", kind: "message", T: () => Timestamp, options: { "validate.rules": { timestamp: { required: true } } } },
            { no: 2, name: "end", kind: "message", T: () => Timestamp, options: { "validate.rules": { timestamp: { required: true } } } },
            { no: 3, name: "component", kind: "enum", T: () => ["pomerium.dashboard.Component", Component], options: { "validate.rules": { enum: { definedOnly: true, notIn: [0] } } } },
            { no: 4, name: "instance_id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } }
        ]);
    }
    create(value?: PartialMessage<UptimeRequest>): UptimeRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.component = 0;
        message.instanceId = "";
        if (value !== undefined)
            reflectionMergePartial<UptimeRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UptimeRequest): UptimeRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.Timestamp start */ 1:
                    message.start = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.start);
                    break;
                case /* google.protobuf.Timestamp end */ 2:
                    message.end = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.end);
                    break;
                case /* pomerium.dashboard.Component component */ 3:
                    message.component = reader.int32();
                    break;
                case /* string instance_id */ 4:
                    message.instanceId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UptimeRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.Timestamp start = 1; */
        if (message.start)
            Timestamp.internalBinaryWrite(message.start, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp end = 2; */
        if (message.end)
            Timestamp.internalBinaryWrite(message.end, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* pomerium.dashboard.Component component = 3; */
        if (message.component !== 0)
            writer.tag(3, WireType.Varint).int32(message.component);
        /* string instance_id = 4; */
        if (message.instanceId !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.instanceId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pomerium.dashboard.UptimeRequest
 */
export const UptimeRequest = new UptimeRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UptimeResponse$Type extends MessageType<UptimeResponse> {
    constructor() {
        super("pomerium.dashboard.UptimeResponse", [
            { no: 1, name: "intervals", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => UptimeResponse_Summary }
        ]);
    }
    create(value?: PartialMessage<UptimeResponse>): UptimeResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.intervals = [];
        if (value !== undefined)
            reflectionMergePartial<UptimeResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UptimeResponse): UptimeResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated pomerium.dashboard.UptimeResponse.Summary intervals */ 1:
                    message.intervals.push(UptimeResponse_Summary.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UptimeResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated pomerium.dashboard.UptimeResponse.Summary intervals = 1; */
        for (let i = 0; i < message.intervals.length; i++)
            UptimeResponse_Summary.internalBinaryWrite(message.intervals[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pomerium.dashboard.UptimeResponse
 */
export const UptimeResponse = new UptimeResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UptimeResponse_Summary$Type extends MessageType<UptimeResponse_Summary> {
    constructor() {
        super("pomerium.dashboard.UptimeResponse.Summary", [
            { no: 1, name: "start", kind: "message", T: () => Timestamp },
            { no: 2, name: "end", kind: "message", T: () => Timestamp },
            { no: 3, name: "status", kind: "enum", T: () => ["pomerium.dashboard.UptimeResponse.Status", UptimeResponse_Status] }
        ]);
    }
    create(value?: PartialMessage<UptimeResponse_Summary>): UptimeResponse_Summary {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.status = 0;
        if (value !== undefined)
            reflectionMergePartial<UptimeResponse_Summary>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UptimeResponse_Summary): UptimeResponse_Summary {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.Timestamp start */ 1:
                    message.start = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.start);
                    break;
                case /* google.protobuf.Timestamp end */ 2:
                    message.end = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.end);
                    break;
                case /* pomerium.dashboard.UptimeResponse.Status status */ 3:
                    message.status = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UptimeResponse_Summary, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.Timestamp start = 1; */
        if (message.start)
            Timestamp.internalBinaryWrite(message.start, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp end = 2; */
        if (message.end)
            Timestamp.internalBinaryWrite(message.end, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* pomerium.dashboard.UptimeResponse.Status status = 3; */
        if (message.status !== 0)
            writer.tag(3, WireType.Varint).int32(message.status);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pomerium.dashboard.UptimeResponse.Summary
 */
export const UptimeResponse_Summary = new UptimeResponse_Summary$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetInstancesRequest$Type extends MessageType<GetInstancesRequest> {
    constructor() {
        super("pomerium.dashboard.GetInstancesRequest", [
            { no: 1, name: "start", kind: "message", T: () => Timestamp, options: { "validate.rules": { timestamp: { required: true } } } },
            { no: 2, name: "end", kind: "message", T: () => Timestamp, options: { "validate.rules": { timestamp: { required: true } } } }
        ]);
    }
    create(value?: PartialMessage<GetInstancesRequest>): GetInstancesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetInstancesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetInstancesRequest): GetInstancesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.Timestamp start */ 1:
                    message.start = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.start);
                    break;
                case /* google.protobuf.Timestamp end */ 2:
                    message.end = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.end);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetInstancesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.Timestamp start = 1; */
        if (message.start)
            Timestamp.internalBinaryWrite(message.start, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp end = 2; */
        if (message.end)
            Timestamp.internalBinaryWrite(message.end, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pomerium.dashboard.GetInstancesRequest
 */
export const GetInstancesRequest = new GetInstancesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Instances$Type extends MessageType<Instances> {
    constructor() {
        super("pomerium.dashboard.Instances", [
            { no: 1, name: "instances", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Instances_Instance }
        ]);
    }
    create(value?: PartialMessage<Instances>): Instances {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.instances = [];
        if (value !== undefined)
            reflectionMergePartial<Instances>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Instances): Instances {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated pomerium.dashboard.Instances.Instance instances */ 1:
                    message.instances.push(Instances_Instance.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Instances, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated pomerium.dashboard.Instances.Instance instances = 1; */
        for (let i = 0; i < message.instances.length; i++)
            Instances_Instance.internalBinaryWrite(message.instances[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pomerium.dashboard.Instances
 */
export const Instances = new Instances$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Instances_Instance$Type extends MessageType<Instances_Instance> {
    constructor() {
        super("pomerium.dashboard.Instances.Instance", [
            { no: 1, name: "component", kind: "enum", T: () => ["pomerium.dashboard.Component", Component] },
            { no: 2, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Instances_Instance>): Instances_Instance {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.component = 0;
        message.id = "";
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<Instances_Instance>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Instances_Instance): Instances_Instance {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* pomerium.dashboard.Component component */ 1:
                    message.component = reader.int32();
                    break;
                case /* string id */ 2:
                    message.id = reader.string();
                    break;
                case /* string name */ 3:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Instances_Instance, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* pomerium.dashboard.Component component = 1; */
        if (message.component !== 0)
            writer.tag(1, WireType.Varint).int32(message.component);
        /* string id = 2; */
        if (message.id !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.id);
        /* string name = 3; */
        if (message.name !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pomerium.dashboard.Instances.Instance
 */
export const Instances_Instance = new Instances_Instance$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetInstanceInfoRequest$Type extends MessageType<GetInstanceInfoRequest> {
    constructor() {
        super("pomerium.dashboard.GetInstanceInfoRequest", [
            { no: 3, name: "component", kind: "enum", T: () => ["pomerium.dashboard.Component", Component], options: { "validate.rules": { enum: { definedOnly: true, notIn: [0] } } } },
            { no: 4, name: "instance_id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } }
        ]);
    }
    create(value?: PartialMessage<GetInstanceInfoRequest>): GetInstanceInfoRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.component = 0;
        message.instanceId = "";
        if (value !== undefined)
            reflectionMergePartial<GetInstanceInfoRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetInstanceInfoRequest): GetInstanceInfoRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* pomerium.dashboard.Component component */ 3:
                    message.component = reader.int32();
                    break;
                case /* string instance_id */ 4:
                    message.instanceId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetInstanceInfoRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* pomerium.dashboard.Component component = 3; */
        if (message.component !== 0)
            writer.tag(3, WireType.Varint).int32(message.component);
        /* string instance_id = 4; */
        if (message.instanceId !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.instanceId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pomerium.dashboard.GetInstanceInfoRequest
 */
export const GetInstanceInfoRequest = new GetInstanceInfoRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetStatusRequest$Type extends MessageType<GetStatusRequest> {
    constructor() {
        super("pomerium.dashboard.GetStatusRequest", []);
    }
    create(value?: PartialMessage<GetStatusRequest>): GetStatusRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetStatusRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetStatusRequest): GetStatusRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: GetStatusRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pomerium.dashboard.GetStatusRequest
 */
export const GetStatusRequest = new GetStatusRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetStatusResponse$Type extends MessageType<GetStatusResponse> {
    constructor() {
        super("pomerium.dashboard.GetStatusResponse", [
            { no: 1, name: "targets", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => GetStatusResponse_Target },
            { no: 2, name: "ok", kind: "scalar", oneof: "status", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "last_error", kind: "scalar", oneof: "status", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetStatusResponse>): GetStatusResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.targets = [];
        message.status = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<GetStatusResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetStatusResponse): GetStatusResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated pomerium.dashboard.GetStatusResponse.Target targets */ 1:
                    message.targets.push(GetStatusResponse_Target.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bool ok */ 2:
                    message.status = {
                        oneofKind: "ok",
                        ok: reader.bool()
                    };
                    break;
                case /* string last_error */ 3:
                    message.status = {
                        oneofKind: "lastError",
                        lastError: reader.string()
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetStatusResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated pomerium.dashboard.GetStatusResponse.Target targets = 1; */
        for (let i = 0; i < message.targets.length; i++)
            GetStatusResponse_Target.internalBinaryWrite(message.targets[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bool ok = 2; */
        if (message.status.oneofKind === "ok")
            writer.tag(2, WireType.Varint).bool(message.status.ok);
        /* string last_error = 3; */
        if (message.status.oneofKind === "lastError")
            writer.tag(3, WireType.LengthDelimited).string(message.status.lastError);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pomerium.dashboard.GetStatusResponse
 */
export const GetStatusResponse = new GetStatusResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetStatusResponse_Target$Type extends MessageType<GetStatusResponse_Target> {
    constructor() {
        super("pomerium.dashboard.GetStatusResponse.Target", [
            { no: 1, name: "scrape_url", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "global_url", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "last_error", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "last_scrape", kind: "message", T: () => Timestamp },
            { no: 5, name: "health", kind: "enum", T: () => ["pomerium.dashboard.GetStatusResponse.Target.Health", GetStatusResponse_Target_Health] }
        ]);
    }
    create(value?: PartialMessage<GetStatusResponse_Target>): GetStatusResponse_Target {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.scrapeUrl = "";
        message.globalUrl = "";
        message.lastError = "";
        message.health = 0;
        if (value !== undefined)
            reflectionMergePartial<GetStatusResponse_Target>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetStatusResponse_Target): GetStatusResponse_Target {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string scrape_url */ 1:
                    message.scrapeUrl = reader.string();
                    break;
                case /* string global_url */ 2:
                    message.globalUrl = reader.string();
                    break;
                case /* string last_error */ 3:
                    message.lastError = reader.string();
                    break;
                case /* google.protobuf.Timestamp last_scrape */ 4:
                    message.lastScrape = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.lastScrape);
                    break;
                case /* pomerium.dashboard.GetStatusResponse.Target.Health health */ 5:
                    message.health = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetStatusResponse_Target, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string scrape_url = 1; */
        if (message.scrapeUrl !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.scrapeUrl);
        /* string global_url = 2; */
        if (message.globalUrl !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.globalUrl);
        /* string last_error = 3; */
        if (message.lastError !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.lastError);
        /* google.protobuf.Timestamp last_scrape = 4; */
        if (message.lastScrape)
            Timestamp.internalBinaryWrite(message.lastScrape, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* pomerium.dashboard.GetStatusResponse.Target.Health health = 5; */
        if (message.health !== 0)
            writer.tag(5, WireType.Varint).int32(message.health);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pomerium.dashboard.GetStatusResponse.Target
 */
export const GetStatusResponse_Target = new GetStatusResponse_Target$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UsageReportRequest$Type extends MessageType<UsageReportRequest> {
    constructor() {
        super("pomerium.dashboard.UsageReportRequest", []);
    }
    create(value?: PartialMessage<UsageReportRequest>): UsageReportRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<UsageReportRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UsageReportRequest): UsageReportRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: UsageReportRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pomerium.dashboard.UsageReportRequest
 */
export const UsageReportRequest = new UsageReportRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UsageReportResponse$Type extends MessageType<UsageReportResponse> {
    constructor() {
        super("pomerium.dashboard.UsageReportResponse", [
            { no: 1, name: "report", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<UsageReportResponse>): UsageReportResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.report = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<UsageReportResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UsageReportResponse): UsageReportResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes report */ 1:
                    message.report = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UsageReportResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes report = 1; */
        if (message.report.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.report);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pomerium.dashboard.UsageReportResponse
 */
export const UsageReportResponse = new UsageReportResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Labels$Type extends MessageType<Labels> {
    constructor() {
        super("pomerium.dashboard.Labels", [
            { no: 1, name: "labels", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } }
        ]);
    }
    create(value?: PartialMessage<Labels>): Labels {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.labels = {};
        if (value !== undefined)
            reflectionMergePartial<Labels>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Labels): Labels {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, string> labels */ 1:
                    this.binaryReadMap1(message.labels, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: Labels["labels"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof Labels["labels"] | undefined, val: Labels["labels"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field pomerium.dashboard.Labels.labels");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: Labels, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, string> labels = 1; */
        for (let k of globalThis.Object.keys(message.labels))
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.labels[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pomerium.dashboard.Labels
 */
export const Labels = new Labels$Type();
/**
 * @generated ServiceType for protobuf service pomerium.dashboard.TimeSeriesDB
 */
export const TimeSeriesDB = new ServiceType("pomerium.dashboard.TimeSeriesDB", [
    { name: "GetRouteMetricChange", options: {}, I: RouteMetricChangeRequest, O: Scalar },
    { name: "GetRouteMetricChangeHistogram", options: {}, I: RouteMetricChangeRequest, O: ScalarBuckets },
    { name: "GetRouteMetricSeries", options: {}, I: RouteMetricSeriesRequest, O: TimeSeriesResponse },
    { name: "GetRouteMetricSeriesHistogram", options: {}, I: RouteMetricSeriesHistogramRequest, O: TimeSeriesResponse },
    { name: "GetRouteMetricSeriesMulti", options: {}, I: RouteMetricSeriesRequest, O: TimeSeriesResponseMulti },
    { name: "GetUptime", options: {}, I: UptimeRequest, O: UptimeResponse },
    { name: "GetInstances", options: {}, I: GetInstancesRequest, O: Instances },
    { name: "GetServerMetricSeries", options: {}, I: ServerMetricSeriesRequest, O: TimeSeriesResponse },
    { name: "GetServerMetric", options: {}, I: ServerMetricRequest, O: Sample },
    { name: "GetStatus", options: {}, I: GetStatusRequest, O: GetStatusResponse },
    { name: "GetLastMetricError", options: {}, I: LastErrorRequest, O: LastErrorResponse },
    { name: "GetUsageReport", options: {}, I: UsageReportRequest, O: UsageReportResponse }
]);
