// @generated by protobuf-ts 2.9.4 with parameter generate_dependencies
// @generated from protobuf file "key_chain.proto" (package "pomerium.dashboard", syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Timestamp } from "./google/protobuf/timestamp";
/**
 * KeyPair represents raw Key Pair data for internal usage
 *
 * @generated from protobuf message pomerium.dashboard.KeyPair
 */
export interface KeyPair {
    /**
     * @generated from protobuf field: string id = 1;
     */
    id: string;
    /**
     * @generated from protobuf field: string name = 2;
     */
    name: string;
    /**
     * @generated from protobuf field: string namespace_id = 3;
     */
    namespaceId: string;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp created_at = 4;
     */
    createdAt?: Timestamp;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp modified_at = 5;
     */
    modifiedAt?: Timestamp;
    /**
     * public certificate data
     *
     * @generated from protobuf field: bytes certificate = 7;
     */
    certificate: Uint8Array;
    /**
     * private key data
     *
     * @generated from protobuf field: bytes key = 8;
     */
    key: Uint8Array;
}
/**
 * KeyUsage specifies the usage flags set on a signed TLS certificate
 *
 * @generated from protobuf message pomerium.dashboard.KeyUsage
 */
export interface KeyUsage {
    /**
     * standard key usages
     *
     * @generated from protobuf field: bool digital_signature = 1;
     */
    digitalSignature: boolean;
    /**
     * @generated from protobuf field: bool content_commitment = 2;
     */
    contentCommitment: boolean;
    /**
     * @generated from protobuf field: bool key_encipherment = 3;
     */
    keyEncipherment: boolean;
    /**
     * @generated from protobuf field: bool data_encipherment = 4;
     */
    dataEncipherment: boolean;
    /**
     * @generated from protobuf field: bool key_agreement = 5;
     */
    keyAgreement: boolean;
    /**
     * certificate authority
     *
     * @generated from protobuf field: bool cert_sign = 6;
     */
    certSign: boolean;
    /**
     * @generated from protobuf field: bool crl_sign = 7;
     */
    crlSign: boolean;
    /**
     * @generated from protobuf field: bool encipher_only = 8;
     */
    encipherOnly: boolean;
    /**
     * @generated from protobuf field: bool decipher_only = 9;
     */
    decipherOnly: boolean;
    /**
     * extensions derived from x509.ExtKeyUsage
     * server certificate
     *
     * @generated from protobuf field: bool server_auth = 10;
     */
    serverAuth: boolean;
    /**
     * client certificate
     *
     * @generated from protobuf field: bool client_auth = 11;
     */
    clientAuth: boolean;
}
/**
 * Name defines the x509 identity
 *
 * @generated from protobuf message pomerium.dashboard.Name
 */
export interface Name {
    /**
     * @generated from protobuf field: repeated string country = 1;
     */
    country: string[];
    /**
     * @generated from protobuf field: repeated string organization = 2;
     */
    organization: string[];
    /**
     * @generated from protobuf field: repeated string organizational_unit = 3;
     */
    organizationalUnit: string[];
    /**
     * @generated from protobuf field: repeated string locality = 4;
     */
    locality: string[];
    /**
     * @generated from protobuf field: repeated string province = 5;
     */
    province: string[];
    /**
     * @generated from protobuf field: repeated string street_address = 6;
     */
    streetAddress: string[];
    /**
     * @generated from protobuf field: repeated string postal_code = 7;
     */
    postalCode: string[];
    /**
     * @generated from protobuf field: string serial_number = 8;
     */
    serialNumber: string;
    /**
     * @generated from protobuf field: string common_name = 9;
     */
    commonName: string;
}
/**
 * CertificateInfo is a .proto reflection of
 * https://golang.org/pkg/crypto/x509/#Certificate
 *
 * @generated from protobuf message pomerium.dashboard.CertificateInfo
 */
export interface CertificateInfo {
    /**
     * @generated from protobuf field: int64 version = 1;
     */
    version: bigint;
    /**
     * @generated from protobuf field: string serial = 2;
     */
    serial: string;
    /**
     * @generated from protobuf field: pomerium.dashboard.Name issuer = 3;
     */
    issuer?: Name;
    /**
     * @generated from protobuf field: pomerium.dashboard.Name subject = 4;
     */
    subject?: Name;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp not_before = 5;
     */
    notBefore?: Timestamp;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp not_after = 6;
     */
    notAfter?: Timestamp;
    /**
     * @generated from protobuf field: pomerium.dashboard.KeyUsage key_usage = 7;
     */
    keyUsage?: KeyUsage;
    /**
     * @generated from protobuf field: repeated string dns_names = 10;
     */
    dnsNames: string[];
    /**
     * @generated from protobuf field: repeated string email_addresses = 11;
     */
    emailAddresses: string[];
    /**
     * @generated from protobuf field: repeated string ip_addresses = 12;
     */
    ipAddresses: string[];
    /**
     * @generated from protobuf field: repeated string uris = 13;
     */
    uris: string[];
    /**
     * @generated from protobuf field: bool permitted_dns_domains_critical = 14;
     */
    permittedDnsDomainsCritical: boolean;
    /**
     * @generated from protobuf field: repeated string permitted_dns_domains = 15;
     */
    permittedDnsDomains: string[];
    /**
     * @generated from protobuf field: repeated string excluded_dns_domains = 16;
     */
    excludedDnsDomains: string[];
    /**
     * @generated from protobuf field: repeated string permitted_ip_ranges = 17;
     */
    permittedIpRanges: string[];
    /**
     * @generated from protobuf field: repeated string excluded_ip_ranges = 18;
     */
    excludedIpRanges: string[];
    /**
     * @generated from protobuf field: repeated string permitted_email_addresses = 19;
     */
    permittedEmailAddresses: string[];
    /**
     * @generated from protobuf field: repeated string excluded_email_addresses = 20;
     */
    excludedEmailAddresses: string[];
    /**
     * @generated from protobuf field: repeated string permitted_uri_domains = 21;
     */
    permittedUriDomains: string[];
    /**
     * @generated from protobuf field: repeated string excluded_uri_domains = 22;
     */
    excludedUriDomains: string[];
}
/**
 * KeyPairRecord provides existing Key Pair metadata
 *
 * @generated from protobuf message pomerium.dashboard.KeyPairRecord
 */
export interface KeyPairRecord {
    /**
     * @generated from protobuf field: string id = 1;
     */
    id: string;
    /**
     * @generated from protobuf field: string name = 2;
     */
    name: string;
    /**
     * @generated from protobuf field: string namespace_id = 3;
     */
    namespaceId: string;
    /**
     * database record creation time
     *
     * @generated from protobuf field: google.protobuf.Timestamp created_at = 4;
     */
    createdAt?: Timestamp;
    /**
     * database record modification time
     *
     * @generated from protobuf field: google.protobuf.Timestamp modified_at = 5;
     */
    modifiedAt?: Timestamp;
    /**
     * information about the public certificate
     *
     * @generated from protobuf field: pomerium.dashboard.CertificateInfo cert_info = 7;
     */
    certInfo?: CertificateInfo;
    /**
     * Key Pair has a private key attached
     *
     * @generated from protobuf field: bool has_private_key = 8;
     */
    hasPrivateKey: boolean;
    /**
     * public certificate data
     *
     * @generated from protobuf field: bytes certificate = 9;
     */
    certificate: Uint8Array;
}
/**
 * @generated from protobuf message pomerium.dashboard.DeleteKeyPairRequest
 */
export interface DeleteKeyPairRequest {
    /**
     * @generated from protobuf field: string id = 1;
     */
    id: string;
}
/**
 * @generated from protobuf message pomerium.dashboard.DeleteKeyPairResponse
 */
export interface DeleteKeyPairResponse {
}
/**
 * @generated from protobuf message pomerium.dashboard.GetKeyPairRequest
 */
export interface GetKeyPairRequest {
    /**
     * @generated from protobuf field: string id = 1;
     */
    id: string;
}
/**
 * @generated from protobuf message pomerium.dashboard.GetKeyPairResponse
 */
export interface GetKeyPairResponse {
    /**
     * @generated from protobuf field: pomerium.dashboard.KeyPairRecord key_pair = 1;
     */
    keyPair?: KeyPairRecord;
}
/**
 * ListKeyPairsRequest defines the types of key pairs to list
 *
 * @generated from protobuf message pomerium.dashboard.ListKeyPairsRequest
 */
export interface ListKeyPairsRequest {
    /**
     * @generated from protobuf field: string namespace_id = 1;
     */
    namespaceId: string;
    /**
     * list Key Pairs whose name contains the query string
     *
     * @generated from protobuf field: optional string query = 2;
     */
    query?: string;
    /**
     * list Key Pairs starting from an offset in the total list
     *
     * @generated from protobuf field: optional int64 offset = 3;
     */
    offset?: bigint;
    /**
     * limit the number of entries returned
     *
     * @generated from protobuf field: optional int64 limit = 4;
     */
    limit?: bigint;
    /**
     * `newest`, `oldest`, `name`, `from`
     *
     * @generated from protobuf field: optional string order_by = 5;
     */
    orderBy?: string;
    /**
     * return key pairs that match the given domain
     *
     * @generated from protobuf field: optional string domain = 6;
     */
    domain?: string;
}
/**
 * ListKeyPairsResponse is the list of Key Pairs found from a
 * ListKeyPairsRequest
 *
 * @generated from protobuf message pomerium.dashboard.ListKeyPairsResponse
 */
export interface ListKeyPairsResponse {
    /**
     * Key Pairs found
     *
     * @generated from protobuf field: repeated pomerium.dashboard.KeyPairRecord key_pairs = 1;
     */
    keyPairs: KeyPairRecord[];
    /**
     * @generated from protobuf field: int64 total_count = 2;
     */
    totalCount: bigint;
}
/**
 * CreateKeyPairRequest defines a Key Pair to create
 *
 * @generated from protobuf message pomerium.dashboard.CreateKeyPairRequest
 */
export interface CreateKeyPairRequest {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: string namespace_id = 2;
     */
    namespaceId: string;
    /**
     * encoding format of data
     *
     * @generated from protobuf field: pomerium.dashboard.Format format = 3;
     */
    format: Format;
    /**
     * public certificate data
     *
     * @generated from protobuf field: bytes certificate = 4;
     */
    certificate: Uint8Array;
    /**
     * private key data
     *
     * @generated from protobuf field: bytes key = 5;
     */
    key: Uint8Array;
}
/**
 * @generated from protobuf message pomerium.dashboard.CreateKeyPairResponse
 */
export interface CreateKeyPairResponse {
    /**
     * @generated from protobuf field: pomerium.dashboard.KeyPairRecord key_pair = 1;
     */
    keyPair?: KeyPairRecord;
}
/**
 * @generated from protobuf message pomerium.dashboard.UpdateKeyPairRequest
 */
export interface UpdateKeyPairRequest {
    /**
     * @generated from protobuf field: string id = 1;
     */
    id: string;
    /**
     * @generated from protobuf field: optional string name = 2;
     */
    name?: string;
    /**
     * encoding format of data
     *
     * @generated from protobuf field: optional pomerium.dashboard.Format format = 3;
     */
    format?: Format;
    /**
     * public certificate data
     *
     * @generated from protobuf field: optional bytes certificate = 4;
     */
    certificate?: Uint8Array;
    /**
     * private key data
     *
     * @generated from protobuf field: optional bytes key = 5;
     */
    key?: Uint8Array;
}
/**
 * @generated from protobuf message pomerium.dashboard.UpdateKeyPairResponse
 */
export interface UpdateKeyPairResponse {
    /**
     * @generated from protobuf field: pomerium.dashboard.KeyPairRecord key_pair = 1;
     */
    keyPair?: KeyPairRecord;
}
/**
 * PublicKeyAlgorithm is the algorithm of a public key
 *
 * @generated from protobuf enum pomerium.dashboard.PublicKeyAlgorithm
 */
export enum PublicKeyAlgorithm {
    /**
     * @generated from protobuf enum value: PKA_UNKNOWN_DO_NOT_USE = 0;
     */
    PKA_UNKNOWN_DO_NOT_USE = 0,
    /**
     * @generated from protobuf enum value: RSA = 1;
     */
    RSA = 1,
    /**
     * @generated from protobuf enum value: DSA = 2;
     */
    DSA = 2,
    /**
     * @generated from protobuf enum value: ECDSA = 3;
     */
    ECDSA = 3,
    /**
     * @generated from protobuf enum value: ED25519 = 4;
     */
    ED25519 = 4
}
/**
 * Format specifies the encoding format of a certificate or key
 *
 * @generated from protobuf enum pomerium.dashboard.Format
 */
export enum Format {
    /**
     * @generated from protobuf enum value: FORMAT_UNDEFINED_DO_NOT_USE = 0;
     */
    FORMAT_UNDEFINED_DO_NOT_USE = 0,
    /**
     * @generated from protobuf enum value: PEM = 1;
     */
    PEM = 1
}
// @generated message type with reflection information, may provide speed optimized methods
class KeyPair$Type extends MessageType<KeyPair> {
    constructor() {
        super("pomerium.dashboard.KeyPair", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "namespace_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "created_at", kind: "message", T: () => Timestamp },
            { no: 5, name: "modified_at", kind: "message", T: () => Timestamp },
            { no: 7, name: "certificate", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 8, name: "key", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<KeyPair>): KeyPair {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.name = "";
        message.namespaceId = "";
        message.certificate = new Uint8Array(0);
        message.key = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<KeyPair>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: KeyPair): KeyPair {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* string namespace_id */ 3:
                    message.namespaceId = reader.string();
                    break;
                case /* google.protobuf.Timestamp created_at */ 4:
                    message.createdAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.createdAt);
                    break;
                case /* google.protobuf.Timestamp modified_at */ 5:
                    message.modifiedAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.modifiedAt);
                    break;
                case /* bytes certificate */ 7:
                    message.certificate = reader.bytes();
                    break;
                case /* bytes key */ 8:
                    message.key = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: KeyPair, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* string namespace_id = 3; */
        if (message.namespaceId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.namespaceId);
        /* google.protobuf.Timestamp created_at = 4; */
        if (message.createdAt)
            Timestamp.internalBinaryWrite(message.createdAt, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp modified_at = 5; */
        if (message.modifiedAt)
            Timestamp.internalBinaryWrite(message.modifiedAt, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* bytes certificate = 7; */
        if (message.certificate.length)
            writer.tag(7, WireType.LengthDelimited).bytes(message.certificate);
        /* bytes key = 8; */
        if (message.key.length)
            writer.tag(8, WireType.LengthDelimited).bytes(message.key);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pomerium.dashboard.KeyPair
 */
export const KeyPair = new KeyPair$Type();
// @generated message type with reflection information, may provide speed optimized methods
class KeyUsage$Type extends MessageType<KeyUsage> {
    constructor() {
        super("pomerium.dashboard.KeyUsage", [
            { no: 1, name: "digital_signature", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "content_commitment", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "key_encipherment", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "data_encipherment", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "key_agreement", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "cert_sign", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "crl_sign", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "encipher_only", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "decipher_only", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 10, name: "server_auth", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 11, name: "client_auth", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<KeyUsage>): KeyUsage {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.digitalSignature = false;
        message.contentCommitment = false;
        message.keyEncipherment = false;
        message.dataEncipherment = false;
        message.keyAgreement = false;
        message.certSign = false;
        message.crlSign = false;
        message.encipherOnly = false;
        message.decipherOnly = false;
        message.serverAuth = false;
        message.clientAuth = false;
        if (value !== undefined)
            reflectionMergePartial<KeyUsage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: KeyUsage): KeyUsage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool digital_signature */ 1:
                    message.digitalSignature = reader.bool();
                    break;
                case /* bool content_commitment */ 2:
                    message.contentCommitment = reader.bool();
                    break;
                case /* bool key_encipherment */ 3:
                    message.keyEncipherment = reader.bool();
                    break;
                case /* bool data_encipherment */ 4:
                    message.dataEncipherment = reader.bool();
                    break;
                case /* bool key_agreement */ 5:
                    message.keyAgreement = reader.bool();
                    break;
                case /* bool cert_sign */ 6:
                    message.certSign = reader.bool();
                    break;
                case /* bool crl_sign */ 7:
                    message.crlSign = reader.bool();
                    break;
                case /* bool encipher_only */ 8:
                    message.encipherOnly = reader.bool();
                    break;
                case /* bool decipher_only */ 9:
                    message.decipherOnly = reader.bool();
                    break;
                case /* bool server_auth */ 10:
                    message.serverAuth = reader.bool();
                    break;
                case /* bool client_auth */ 11:
                    message.clientAuth = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: KeyUsage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool digital_signature = 1; */
        if (message.digitalSignature !== false)
            writer.tag(1, WireType.Varint).bool(message.digitalSignature);
        /* bool content_commitment = 2; */
        if (message.contentCommitment !== false)
            writer.tag(2, WireType.Varint).bool(message.contentCommitment);
        /* bool key_encipherment = 3; */
        if (message.keyEncipherment !== false)
            writer.tag(3, WireType.Varint).bool(message.keyEncipherment);
        /* bool data_encipherment = 4; */
        if (message.dataEncipherment !== false)
            writer.tag(4, WireType.Varint).bool(message.dataEncipherment);
        /* bool key_agreement = 5; */
        if (message.keyAgreement !== false)
            writer.tag(5, WireType.Varint).bool(message.keyAgreement);
        /* bool cert_sign = 6; */
        if (message.certSign !== false)
            writer.tag(6, WireType.Varint).bool(message.certSign);
        /* bool crl_sign = 7; */
        if (message.crlSign !== false)
            writer.tag(7, WireType.Varint).bool(message.crlSign);
        /* bool encipher_only = 8; */
        if (message.encipherOnly !== false)
            writer.tag(8, WireType.Varint).bool(message.encipherOnly);
        /* bool decipher_only = 9; */
        if (message.decipherOnly !== false)
            writer.tag(9, WireType.Varint).bool(message.decipherOnly);
        /* bool server_auth = 10; */
        if (message.serverAuth !== false)
            writer.tag(10, WireType.Varint).bool(message.serverAuth);
        /* bool client_auth = 11; */
        if (message.clientAuth !== false)
            writer.tag(11, WireType.Varint).bool(message.clientAuth);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pomerium.dashboard.KeyUsage
 */
export const KeyUsage = new KeyUsage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Name$Type extends MessageType<Name> {
    constructor() {
        super("pomerium.dashboard.Name", [
            { no: 1, name: "country", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "organization", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "organizational_unit", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "locality", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "province", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "street_address", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "postal_code", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "serial_number", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "common_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Name>): Name {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.country = [];
        message.organization = [];
        message.organizationalUnit = [];
        message.locality = [];
        message.province = [];
        message.streetAddress = [];
        message.postalCode = [];
        message.serialNumber = "";
        message.commonName = "";
        if (value !== undefined)
            reflectionMergePartial<Name>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Name): Name {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string country */ 1:
                    message.country.push(reader.string());
                    break;
                case /* repeated string organization */ 2:
                    message.organization.push(reader.string());
                    break;
                case /* repeated string organizational_unit */ 3:
                    message.organizationalUnit.push(reader.string());
                    break;
                case /* repeated string locality */ 4:
                    message.locality.push(reader.string());
                    break;
                case /* repeated string province */ 5:
                    message.province.push(reader.string());
                    break;
                case /* repeated string street_address */ 6:
                    message.streetAddress.push(reader.string());
                    break;
                case /* repeated string postal_code */ 7:
                    message.postalCode.push(reader.string());
                    break;
                case /* string serial_number */ 8:
                    message.serialNumber = reader.string();
                    break;
                case /* string common_name */ 9:
                    message.commonName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Name, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string country = 1; */
        for (let i = 0; i < message.country.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.country[i]);
        /* repeated string organization = 2; */
        for (let i = 0; i < message.organization.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.organization[i]);
        /* repeated string organizational_unit = 3; */
        for (let i = 0; i < message.organizationalUnit.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.organizationalUnit[i]);
        /* repeated string locality = 4; */
        for (let i = 0; i < message.locality.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.locality[i]);
        /* repeated string province = 5; */
        for (let i = 0; i < message.province.length; i++)
            writer.tag(5, WireType.LengthDelimited).string(message.province[i]);
        /* repeated string street_address = 6; */
        for (let i = 0; i < message.streetAddress.length; i++)
            writer.tag(6, WireType.LengthDelimited).string(message.streetAddress[i]);
        /* repeated string postal_code = 7; */
        for (let i = 0; i < message.postalCode.length; i++)
            writer.tag(7, WireType.LengthDelimited).string(message.postalCode[i]);
        /* string serial_number = 8; */
        if (message.serialNumber !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.serialNumber);
        /* string common_name = 9; */
        if (message.commonName !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.commonName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pomerium.dashboard.Name
 */
export const Name = new Name$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CertificateInfo$Type extends MessageType<CertificateInfo> {
    constructor() {
        super("pomerium.dashboard.CertificateInfo", [
            { no: 1, name: "version", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "serial", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "issuer", kind: "message", T: () => Name },
            { no: 4, name: "subject", kind: "message", T: () => Name },
            { no: 5, name: "not_before", kind: "message", T: () => Timestamp },
            { no: 6, name: "not_after", kind: "message", T: () => Timestamp },
            { no: 7, name: "key_usage", kind: "message", T: () => KeyUsage },
            { no: 10, name: "dns_names", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "email_addresses", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "ip_addresses", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "uris", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 14, name: "permitted_dns_domains_critical", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 15, name: "permitted_dns_domains", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 16, name: "excluded_dns_domains", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 17, name: "permitted_ip_ranges", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 18, name: "excluded_ip_ranges", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 19, name: "permitted_email_addresses", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 20, name: "excluded_email_addresses", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 21, name: "permitted_uri_domains", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 22, name: "excluded_uri_domains", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CertificateInfo>): CertificateInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.version = 0n;
        message.serial = "";
        message.dnsNames = [];
        message.emailAddresses = [];
        message.ipAddresses = [];
        message.uris = [];
        message.permittedDnsDomainsCritical = false;
        message.permittedDnsDomains = [];
        message.excludedDnsDomains = [];
        message.permittedIpRanges = [];
        message.excludedIpRanges = [];
        message.permittedEmailAddresses = [];
        message.excludedEmailAddresses = [];
        message.permittedUriDomains = [];
        message.excludedUriDomains = [];
        if (value !== undefined)
            reflectionMergePartial<CertificateInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CertificateInfo): CertificateInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 version */ 1:
                    message.version = reader.int64().toBigInt();
                    break;
                case /* string serial */ 2:
                    message.serial = reader.string();
                    break;
                case /* pomerium.dashboard.Name issuer */ 3:
                    message.issuer = Name.internalBinaryRead(reader, reader.uint32(), options, message.issuer);
                    break;
                case /* pomerium.dashboard.Name subject */ 4:
                    message.subject = Name.internalBinaryRead(reader, reader.uint32(), options, message.subject);
                    break;
                case /* google.protobuf.Timestamp not_before */ 5:
                    message.notBefore = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.notBefore);
                    break;
                case /* google.protobuf.Timestamp not_after */ 6:
                    message.notAfter = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.notAfter);
                    break;
                case /* pomerium.dashboard.KeyUsage key_usage */ 7:
                    message.keyUsage = KeyUsage.internalBinaryRead(reader, reader.uint32(), options, message.keyUsage);
                    break;
                case /* repeated string dns_names */ 10:
                    message.dnsNames.push(reader.string());
                    break;
                case /* repeated string email_addresses */ 11:
                    message.emailAddresses.push(reader.string());
                    break;
                case /* repeated string ip_addresses */ 12:
                    message.ipAddresses.push(reader.string());
                    break;
                case /* repeated string uris */ 13:
                    message.uris.push(reader.string());
                    break;
                case /* bool permitted_dns_domains_critical */ 14:
                    message.permittedDnsDomainsCritical = reader.bool();
                    break;
                case /* repeated string permitted_dns_domains */ 15:
                    message.permittedDnsDomains.push(reader.string());
                    break;
                case /* repeated string excluded_dns_domains */ 16:
                    message.excludedDnsDomains.push(reader.string());
                    break;
                case /* repeated string permitted_ip_ranges */ 17:
                    message.permittedIpRanges.push(reader.string());
                    break;
                case /* repeated string excluded_ip_ranges */ 18:
                    message.excludedIpRanges.push(reader.string());
                    break;
                case /* repeated string permitted_email_addresses */ 19:
                    message.permittedEmailAddresses.push(reader.string());
                    break;
                case /* repeated string excluded_email_addresses */ 20:
                    message.excludedEmailAddresses.push(reader.string());
                    break;
                case /* repeated string permitted_uri_domains */ 21:
                    message.permittedUriDomains.push(reader.string());
                    break;
                case /* repeated string excluded_uri_domains */ 22:
                    message.excludedUriDomains.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CertificateInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 version = 1; */
        if (message.version !== 0n)
            writer.tag(1, WireType.Varint).int64(message.version);
        /* string serial = 2; */
        if (message.serial !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.serial);
        /* pomerium.dashboard.Name issuer = 3; */
        if (message.issuer)
            Name.internalBinaryWrite(message.issuer, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* pomerium.dashboard.Name subject = 4; */
        if (message.subject)
            Name.internalBinaryWrite(message.subject, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp not_before = 5; */
        if (message.notBefore)
            Timestamp.internalBinaryWrite(message.notBefore, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp not_after = 6; */
        if (message.notAfter)
            Timestamp.internalBinaryWrite(message.notAfter, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* pomerium.dashboard.KeyUsage key_usage = 7; */
        if (message.keyUsage)
            KeyUsage.internalBinaryWrite(message.keyUsage, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* repeated string dns_names = 10; */
        for (let i = 0; i < message.dnsNames.length; i++)
            writer.tag(10, WireType.LengthDelimited).string(message.dnsNames[i]);
        /* repeated string email_addresses = 11; */
        for (let i = 0; i < message.emailAddresses.length; i++)
            writer.tag(11, WireType.LengthDelimited).string(message.emailAddresses[i]);
        /* repeated string ip_addresses = 12; */
        for (let i = 0; i < message.ipAddresses.length; i++)
            writer.tag(12, WireType.LengthDelimited).string(message.ipAddresses[i]);
        /* repeated string uris = 13; */
        for (let i = 0; i < message.uris.length; i++)
            writer.tag(13, WireType.LengthDelimited).string(message.uris[i]);
        /* bool permitted_dns_domains_critical = 14; */
        if (message.permittedDnsDomainsCritical !== false)
            writer.tag(14, WireType.Varint).bool(message.permittedDnsDomainsCritical);
        /* repeated string permitted_dns_domains = 15; */
        for (let i = 0; i < message.permittedDnsDomains.length; i++)
            writer.tag(15, WireType.LengthDelimited).string(message.permittedDnsDomains[i]);
        /* repeated string excluded_dns_domains = 16; */
        for (let i = 0; i < message.excludedDnsDomains.length; i++)
            writer.tag(16, WireType.LengthDelimited).string(message.excludedDnsDomains[i]);
        /* repeated string permitted_ip_ranges = 17; */
        for (let i = 0; i < message.permittedIpRanges.length; i++)
            writer.tag(17, WireType.LengthDelimited).string(message.permittedIpRanges[i]);
        /* repeated string excluded_ip_ranges = 18; */
        for (let i = 0; i < message.excludedIpRanges.length; i++)
            writer.tag(18, WireType.LengthDelimited).string(message.excludedIpRanges[i]);
        /* repeated string permitted_email_addresses = 19; */
        for (let i = 0; i < message.permittedEmailAddresses.length; i++)
            writer.tag(19, WireType.LengthDelimited).string(message.permittedEmailAddresses[i]);
        /* repeated string excluded_email_addresses = 20; */
        for (let i = 0; i < message.excludedEmailAddresses.length; i++)
            writer.tag(20, WireType.LengthDelimited).string(message.excludedEmailAddresses[i]);
        /* repeated string permitted_uri_domains = 21; */
        for (let i = 0; i < message.permittedUriDomains.length; i++)
            writer.tag(21, WireType.LengthDelimited).string(message.permittedUriDomains[i]);
        /* repeated string excluded_uri_domains = 22; */
        for (let i = 0; i < message.excludedUriDomains.length; i++)
            writer.tag(22, WireType.LengthDelimited).string(message.excludedUriDomains[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pomerium.dashboard.CertificateInfo
 */
export const CertificateInfo = new CertificateInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class KeyPairRecord$Type extends MessageType<KeyPairRecord> {
    constructor() {
        super("pomerium.dashboard.KeyPairRecord", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "namespace_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "created_at", kind: "message", T: () => Timestamp },
            { no: 5, name: "modified_at", kind: "message", T: () => Timestamp },
            { no: 7, name: "cert_info", kind: "message", T: () => CertificateInfo },
            { no: 8, name: "has_private_key", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "certificate", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<KeyPairRecord>): KeyPairRecord {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.name = "";
        message.namespaceId = "";
        message.hasPrivateKey = false;
        message.certificate = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<KeyPairRecord>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: KeyPairRecord): KeyPairRecord {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* string namespace_id */ 3:
                    message.namespaceId = reader.string();
                    break;
                case /* google.protobuf.Timestamp created_at */ 4:
                    message.createdAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.createdAt);
                    break;
                case /* google.protobuf.Timestamp modified_at */ 5:
                    message.modifiedAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.modifiedAt);
                    break;
                case /* pomerium.dashboard.CertificateInfo cert_info */ 7:
                    message.certInfo = CertificateInfo.internalBinaryRead(reader, reader.uint32(), options, message.certInfo);
                    break;
                case /* bool has_private_key */ 8:
                    message.hasPrivateKey = reader.bool();
                    break;
                case /* bytes certificate */ 9:
                    message.certificate = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: KeyPairRecord, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* string namespace_id = 3; */
        if (message.namespaceId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.namespaceId);
        /* google.protobuf.Timestamp created_at = 4; */
        if (message.createdAt)
            Timestamp.internalBinaryWrite(message.createdAt, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp modified_at = 5; */
        if (message.modifiedAt)
            Timestamp.internalBinaryWrite(message.modifiedAt, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* pomerium.dashboard.CertificateInfo cert_info = 7; */
        if (message.certInfo)
            CertificateInfo.internalBinaryWrite(message.certInfo, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* bool has_private_key = 8; */
        if (message.hasPrivateKey !== false)
            writer.tag(8, WireType.Varint).bool(message.hasPrivateKey);
        /* bytes certificate = 9; */
        if (message.certificate.length)
            writer.tag(9, WireType.LengthDelimited).bytes(message.certificate);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pomerium.dashboard.KeyPairRecord
 */
export const KeyPairRecord = new KeyPairRecord$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteKeyPairRequest$Type extends MessageType<DeleteKeyPairRequest> {
    constructor() {
        super("pomerium.dashboard.DeleteKeyPairRequest", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DeleteKeyPairRequest>): DeleteKeyPairRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        if (value !== undefined)
            reflectionMergePartial<DeleteKeyPairRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteKeyPairRequest): DeleteKeyPairRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteKeyPairRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pomerium.dashboard.DeleteKeyPairRequest
 */
export const DeleteKeyPairRequest = new DeleteKeyPairRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteKeyPairResponse$Type extends MessageType<DeleteKeyPairResponse> {
    constructor() {
        super("pomerium.dashboard.DeleteKeyPairResponse", []);
    }
    create(value?: PartialMessage<DeleteKeyPairResponse>): DeleteKeyPairResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<DeleteKeyPairResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteKeyPairResponse): DeleteKeyPairResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: DeleteKeyPairResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pomerium.dashboard.DeleteKeyPairResponse
 */
export const DeleteKeyPairResponse = new DeleteKeyPairResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetKeyPairRequest$Type extends MessageType<GetKeyPairRequest> {
    constructor() {
        super("pomerium.dashboard.GetKeyPairRequest", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetKeyPairRequest>): GetKeyPairRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        if (value !== undefined)
            reflectionMergePartial<GetKeyPairRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetKeyPairRequest): GetKeyPairRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetKeyPairRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pomerium.dashboard.GetKeyPairRequest
 */
export const GetKeyPairRequest = new GetKeyPairRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetKeyPairResponse$Type extends MessageType<GetKeyPairResponse> {
    constructor() {
        super("pomerium.dashboard.GetKeyPairResponse", [
            { no: 1, name: "key_pair", kind: "message", T: () => KeyPairRecord }
        ]);
    }
    create(value?: PartialMessage<GetKeyPairResponse>): GetKeyPairResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetKeyPairResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetKeyPairResponse): GetKeyPairResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* pomerium.dashboard.KeyPairRecord key_pair */ 1:
                    message.keyPair = KeyPairRecord.internalBinaryRead(reader, reader.uint32(), options, message.keyPair);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetKeyPairResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* pomerium.dashboard.KeyPairRecord key_pair = 1; */
        if (message.keyPair)
            KeyPairRecord.internalBinaryWrite(message.keyPair, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pomerium.dashboard.GetKeyPairResponse
 */
export const GetKeyPairResponse = new GetKeyPairResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListKeyPairsRequest$Type extends MessageType<ListKeyPairsRequest> {
    constructor() {
        super("pomerium.dashboard.ListKeyPairsRequest", [
            { no: 1, name: "namespace_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "query", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "offset", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "limit", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "order_by", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "domain", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ListKeyPairsRequest>): ListKeyPairsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.namespaceId = "";
        if (value !== undefined)
            reflectionMergePartial<ListKeyPairsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListKeyPairsRequest): ListKeyPairsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string namespace_id */ 1:
                    message.namespaceId = reader.string();
                    break;
                case /* optional string query */ 2:
                    message.query = reader.string();
                    break;
                case /* optional int64 offset */ 3:
                    message.offset = reader.int64().toBigInt();
                    break;
                case /* optional int64 limit */ 4:
                    message.limit = reader.int64().toBigInt();
                    break;
                case /* optional string order_by */ 5:
                    message.orderBy = reader.string();
                    break;
                case /* optional string domain */ 6:
                    message.domain = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListKeyPairsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string namespace_id = 1; */
        if (message.namespaceId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.namespaceId);
        /* optional string query = 2; */
        if (message.query !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.query);
        /* optional int64 offset = 3; */
        if (message.offset !== undefined)
            writer.tag(3, WireType.Varint).int64(message.offset);
        /* optional int64 limit = 4; */
        if (message.limit !== undefined)
            writer.tag(4, WireType.Varint).int64(message.limit);
        /* optional string order_by = 5; */
        if (message.orderBy !== undefined)
            writer.tag(5, WireType.LengthDelimited).string(message.orderBy);
        /* optional string domain = 6; */
        if (message.domain !== undefined)
            writer.tag(6, WireType.LengthDelimited).string(message.domain);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pomerium.dashboard.ListKeyPairsRequest
 */
export const ListKeyPairsRequest = new ListKeyPairsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListKeyPairsResponse$Type extends MessageType<ListKeyPairsResponse> {
    constructor() {
        super("pomerium.dashboard.ListKeyPairsResponse", [
            { no: 1, name: "key_pairs", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => KeyPairRecord },
            { no: 2, name: "total_count", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<ListKeyPairsResponse>): ListKeyPairsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.keyPairs = [];
        message.totalCount = 0n;
        if (value !== undefined)
            reflectionMergePartial<ListKeyPairsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListKeyPairsResponse): ListKeyPairsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated pomerium.dashboard.KeyPairRecord key_pairs */ 1:
                    message.keyPairs.push(KeyPairRecord.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* int64 total_count */ 2:
                    message.totalCount = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListKeyPairsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated pomerium.dashboard.KeyPairRecord key_pairs = 1; */
        for (let i = 0; i < message.keyPairs.length; i++)
            KeyPairRecord.internalBinaryWrite(message.keyPairs[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* int64 total_count = 2; */
        if (message.totalCount !== 0n)
            writer.tag(2, WireType.Varint).int64(message.totalCount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pomerium.dashboard.ListKeyPairsResponse
 */
export const ListKeyPairsResponse = new ListKeyPairsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateKeyPairRequest$Type extends MessageType<CreateKeyPairRequest> {
    constructor() {
        super("pomerium.dashboard.CreateKeyPairRequest", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "namespace_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "format", kind: "enum", T: () => ["pomerium.dashboard.Format", Format] },
            { no: 4, name: "certificate", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 5, name: "key", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<CreateKeyPairRequest>): CreateKeyPairRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.namespaceId = "";
        message.format = 0;
        message.certificate = new Uint8Array(0);
        message.key = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<CreateKeyPairRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateKeyPairRequest): CreateKeyPairRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string namespace_id */ 2:
                    message.namespaceId = reader.string();
                    break;
                case /* pomerium.dashboard.Format format */ 3:
                    message.format = reader.int32();
                    break;
                case /* bytes certificate */ 4:
                    message.certificate = reader.bytes();
                    break;
                case /* bytes key */ 5:
                    message.key = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateKeyPairRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string namespace_id = 2; */
        if (message.namespaceId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.namespaceId);
        /* pomerium.dashboard.Format format = 3; */
        if (message.format !== 0)
            writer.tag(3, WireType.Varint).int32(message.format);
        /* bytes certificate = 4; */
        if (message.certificate.length)
            writer.tag(4, WireType.LengthDelimited).bytes(message.certificate);
        /* bytes key = 5; */
        if (message.key.length)
            writer.tag(5, WireType.LengthDelimited).bytes(message.key);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pomerium.dashboard.CreateKeyPairRequest
 */
export const CreateKeyPairRequest = new CreateKeyPairRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateKeyPairResponse$Type extends MessageType<CreateKeyPairResponse> {
    constructor() {
        super("pomerium.dashboard.CreateKeyPairResponse", [
            { no: 1, name: "key_pair", kind: "message", T: () => KeyPairRecord }
        ]);
    }
    create(value?: PartialMessage<CreateKeyPairResponse>): CreateKeyPairResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CreateKeyPairResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateKeyPairResponse): CreateKeyPairResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* pomerium.dashboard.KeyPairRecord key_pair */ 1:
                    message.keyPair = KeyPairRecord.internalBinaryRead(reader, reader.uint32(), options, message.keyPair);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateKeyPairResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* pomerium.dashboard.KeyPairRecord key_pair = 1; */
        if (message.keyPair)
            KeyPairRecord.internalBinaryWrite(message.keyPair, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pomerium.dashboard.CreateKeyPairResponse
 */
export const CreateKeyPairResponse = new CreateKeyPairResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateKeyPairRequest$Type extends MessageType<UpdateKeyPairRequest> {
    constructor() {
        super("pomerium.dashboard.UpdateKeyPairRequest", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "format", kind: "enum", opt: true, T: () => ["pomerium.dashboard.Format", Format] },
            { no: 4, name: "certificate", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 5, name: "key", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<UpdateKeyPairRequest>): UpdateKeyPairRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        if (value !== undefined)
            reflectionMergePartial<UpdateKeyPairRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateKeyPairRequest): UpdateKeyPairRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* optional string name */ 2:
                    message.name = reader.string();
                    break;
                case /* optional pomerium.dashboard.Format format */ 3:
                    message.format = reader.int32();
                    break;
                case /* optional bytes certificate */ 4:
                    message.certificate = reader.bytes();
                    break;
                case /* optional bytes key */ 5:
                    message.key = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateKeyPairRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* optional string name = 2; */
        if (message.name !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* optional pomerium.dashboard.Format format = 3; */
        if (message.format !== undefined)
            writer.tag(3, WireType.Varint).int32(message.format);
        /* optional bytes certificate = 4; */
        if (message.certificate !== undefined)
            writer.tag(4, WireType.LengthDelimited).bytes(message.certificate);
        /* optional bytes key = 5; */
        if (message.key !== undefined)
            writer.tag(5, WireType.LengthDelimited).bytes(message.key);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pomerium.dashboard.UpdateKeyPairRequest
 */
export const UpdateKeyPairRequest = new UpdateKeyPairRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateKeyPairResponse$Type extends MessageType<UpdateKeyPairResponse> {
    constructor() {
        super("pomerium.dashboard.UpdateKeyPairResponse", [
            { no: 1, name: "key_pair", kind: "message", T: () => KeyPairRecord }
        ]);
    }
    create(value?: PartialMessage<UpdateKeyPairResponse>): UpdateKeyPairResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<UpdateKeyPairResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateKeyPairResponse): UpdateKeyPairResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* pomerium.dashboard.KeyPairRecord key_pair */ 1:
                    message.keyPair = KeyPairRecord.internalBinaryRead(reader, reader.uint32(), options, message.keyPair);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateKeyPairResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* pomerium.dashboard.KeyPairRecord key_pair = 1; */
        if (message.keyPair)
            KeyPairRecord.internalBinaryWrite(message.keyPair, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pomerium.dashboard.UpdateKeyPairResponse
 */
export const UpdateKeyPairResponse = new UpdateKeyPairResponse$Type();
/**
 * @generated ServiceType for protobuf service pomerium.dashboard.KeyChainService
 */
export const KeyChainService = new ServiceType("pomerium.dashboard.KeyChainService", [
    { name: "DeleteKeyPair", options: {}, I: DeleteKeyPairRequest, O: DeleteKeyPairResponse },
    { name: "GetKeyPair", options: {}, I: GetKeyPairRequest, O: GetKeyPairResponse },
    { name: "ListKeyPairs", options: {}, I: ListKeyPairsRequest, O: ListKeyPairsResponse },
    { name: "CreateKeyPair", options: {}, I: CreateKeyPairRequest, O: CreateKeyPairResponse },
    { name: "UpdateKeyPair", options: {}, I: UpdateKeyPairRequest, O: UpdateKeyPairResponse }
]);
